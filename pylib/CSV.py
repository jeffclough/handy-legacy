"""
NAME
    CSV - CSV parsing and writing.

CAVEAT!!!
    This CSV module is mostly copied and slightly augmented from Python's
    standard csv module to accommodate reading CSV files that might have
    commented lines. This is VERY non-standard, but ... since when did CSV
    have a standard? In any case, the default comment character is # and will
    obscure any line where it is the first character.

    This CSV module also adds provision for specifying a dialect string.

DESCRIPTION
    This module provides classes that assist in the reading and writing
    of Comma Separated Value (CSV) files, and implements the interface
    described by PEP 305.  Although many CSV files are simple to parse,
    the format is not formally defined by a stable specification and
    is subtle enough that parsing lines of a CSV file with something
    like line.split(",") is bound to fail.  The module supports three
    basic APIs: reading, writing, and registration of dialects.


    DIALECT REGISTRATION:

    Readers and writers support a dialect argument, which is a convenient
    handle on a group of settings.  When the dialect argument is a string,
    it identifies one of the dialects previously registered with the module.
    If it is a class or instance, the attributes of the argument are used as
    the settings for the reader or writer:

        class excel:
            delimiter = ','
            quotechar = '"'
            escapechar = None
            doublequote = True
            skipinitialspace = False
            lineterminator = '\\r\\n'
            quoting = QUOTE_MINIMAL
            commentchar = #

    SETTINGS:

        * quotechar - specifies a one-character string to use as the
            quoting character.  It defaults to '"'.
        * delimiter - specifies a one-character string to use as the
            field separator.  It defaults to ','.
        * skipinitialspace - specifies how to interpret whitespace which
            immediately follows a delimiter.  It defaults to False, which
            means that whitespace immediately following a delimiter is part
            of the following field.
        * lineterminator -  specifies the character sequence which should
            terminate rows.
        * quoting - controls when quotes should be generated by the writer.
            It can take on any of the following module constants:

            csv.QUOTE_MINIMAL means only when required, for example, when a
                field contains either the quotechar or the delimiter
            csv.QUOTE_ALL means that quotes are always placed around fields.
            csv.QUOTE_NONNUMERIC means that quotes are always placed around
                fields which do not parse as integers or floating point
                numbers.
            csv.QUOTE_NONE means that quotes are never placed around fields.
        * escapechar - specifies a one-character string used to escape
            the delimiter when quoting is set to QUOTE_NONE.
        * doublequote - controls the handling of quotes inside fields.  When
            True, two consecutive quotes are interpreted as one during read,
            and when writing, each quote character embedded in the data is
            written as two quotes.
"""

__all__ = [
  "CSV_DIALECT_DESCRIPTION",
  "DEFAULT_DIALECT_SPEC",
  "Dialect",
  "DictReader",
  "DictWriter",
  "Error",
  "QUOTE_ALL",
  "QUOTE_MINIMAL",
  "QUOTE_NONE",
  "QUOTE_NONNUMERIC",
  "Sniffer",
  "__doc__",
  "__version__",
  "excel",
  "excel_tab",
  "field_size_limit",
  "get_dialect",
  "list_dialects",
  "parse_dialect",
  "reader",
  "register_dialect",
  "unix_dialect",
  "unregister_dialect",
  "writer",
]

 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# ALMOST entirely stolen from Python 3.8.9's csv.py file.
#

from csv import Dialect as _Dialect,DictReader,DictWriter,Error,QUOTE_ALL,QUOTE_MINIMAL,QUOTE_NONE,QUOTE_NONNUMERIC,Sniffer,__version__,excel,excel_tab,field_size_limit,get_dialect,list_dialects,reader as _reader,register_dialect,unix_dialect,unregister_dialect,writer
import re

class Dialect(_Dialect):
  """Describe a CSV dialect.

  This must be subclassed (see csv.excel). Valid attributes are:
  delimiter, quotechar, escapechar, doublequote, skipinitialspace,
  lineterminator, quoting, and commentchar."""

  commentchar=None

class excel(Dialect):
  """Describe the usual properties of Excel-generated CSV files."""

  delimiter=','
  quotechar='"'
  doublequote=True
  skipinitialspace=False
  lineterminator='\r\n'
  quoting=QUOTE_MINIMAL
  commentchar='#'
register_dialect("excel",excel)

class excel_tab(excel):
  """Describe the usual properties of Excel-generated TAB-delimited files."""

  delimiter = '\t'
register_dialect("excel-tab", excel_tab)

class unix_dialect(Dialect):
  """Describe the usual properties of Unix-generated CSV files."""

  delimiter=','
  quotechar='"'
  doublequote=True
  skipinitialspace=False
  lineterminator='\n'
  quoting=QUOTE_ALL
  commentchar='#'
register_dialect("unix",unix_dialect)

#
# Plagiarism ends (mostly).
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

CSV_DIALECT_DESCRIPTION="""\
CSV formatting is a loose standard with dialectic flexability. These are the
parameters involved:

    SEP:     Field separator character. (default: ,)
    Q:       Quote character. (default: ")
    QSTYLE:  Quoting style. One of 'a' (all), 'm' (minimal, the default),
             'N' (non-numeric), or 'n' (none).
    DQUOTE:  Represent a literal quote as two consecutive quotes. Either
             't' (for True, the default) or 'f' (for False).
    ESC:     The escape charater, which makes the next character a literal.
             (default: \\)
    SKIPWS:  Skip whitespace immediately following a field separator. Either
             't' (for True) or 'f' (for False, the default).
    COMMENT: The character, if any, that makes a CSV line a comment IF it is
             the first character on that line. (default: '#')

All this put together looks like SEP[Q[QSTYLE[DQUOTE[ESC[SKIPWS]]]]] and is a
single string of up to seven characters."""

DEFAULT_DIALECT_SPEC=',"Bmt\\f#'

# This regular expression matches a complete CSV dialect specification string.
re_dialect=re.compile(
  '^'
  '(?P<delimiter>.)'
  '(?P<quotechar>.)'
  '(?P<lineterminator>.)'
  '(?P<quoting>[amNn])'
  '(?P<doublequote>[ft])'
  '(?P<escapechar>.)'
  '(?P<skipinitialspace>[ft])'
  '(?P<commentchar>.)'
  '$'
)

quoting_map=dict(
  a=QUOTE_ALL,
  m=QUOTE_MINIMAL,
  N=QUOTE_NONNUMERIC,
  n=QUOTE_NONE
)

lineterminator_map=dict(
  B='\r\n',
  C='\r',
  N='\n',
  L='\n'
)

def parse_dialect(dialect_name,dialect_spec):
  """Parse a dialect string, create a corresponding Dialect subclass and
  register that named dialect class.

  CSV formatting is a loose standard with dialectic flexability. These are the
  parameters involved:

      SEP:     Field separator character. (default: ,)
      Q:       Quote character. (default: ")
      QSTYLE:  Quoting style. One of 'a' (all), 'm' (minimal, the
               default), 'N' (non-numeric), or 'n' (none).
      DQUOTE:  Represent a literal quote as two consecutive quotes.
               Either 't' (for True, the default) or 'f' (for False).
      ESC:     The escape charater, which makes the next character a
               literal. (default: \\)
      SKIPWS:  Skip whitespace immediately following a field separator.
               Either 't' (for True) or 'f' (for False, the default).
      COMMENT: The character, if any, that makes a CSV line a comment IF
               it is the first character on that line. (default: '#')

  All this put together looks like SEP[Q[QSTYLE[DQUOTE[ESC[SKIPWS]]]]]
  and is a single string of up to seven characters.

  """

  # Supply defaults for any unspecified elements of the dialect string.
  if len(dialect_spec)>len(DEFAULT_DIALECT_SPEC):
    raise Error(f"Dialect specification string too long: {dialect_spec!r}")
  if len(dialect_spec)<len(DEFAULT_DIALECT_SPEC):
    dialect_spec+=default_dialect_spec[-(len(default_dialect_spec)-len(dialect_spec)):]

  # Validate and parse the dialect string using a regular expression.
  m=re_dialect.match(dialect_spec)
  if m==None:
    raise Error(f"Bad dialect specification string: {dialect_spec!r}")

  # Cook this dialect spec's non-literal values.
  d=m.groupdict()
  try:
    d['quoting']=quoting_map[d['quoting']]
  except KeyError:
    raise Error(f"Bad \"quoting\" value in dialect specification string: {dialect_spec!r}")
  except:
    raise
  d['doublequote']=d['doublequote']=='t'
  d['skipinitialspace']=d['skipinitialspace']=='t'
  d['lineterminator']=lineterminator_map.get(d['lineterminator'],d['lineterminator'])

  # Create our new dialect class, and register it.
  dialect_class=type(dialect_name,(Dialect,),{
    delimiter:d['delimiter'],
    quotechar:d['quotechar'],
    escapechar:d['escapechar'],
    doublequote:d['doublequote'],
    skipinitialspace:d['skipinitialspace'],
    lineterminator:d['lineterminator'],
    quoting:d['quoting'],
    commentchar:d['commentchar'],
  })
  register_dialect(dialect_name,dialect_class)

 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Augment CSV readers to ignore comment lines.
#

def reader(iterable,dialect='excel',*args,**kwds):
  """The "iterable" argument can be any object that returns a line of
  input for each iteration, such as a file object or a list. The
  optional "dialect" parameter is discussed below.  The function also
  accepts optional keyword arguments which override settings provided by
  the dialect.

  The returned object is an iterator. Each iteration returns a row of
  the CSV file (which can span multiple input lines). This reader
  recognizes comment lines. Such lines are not returned during iteration
  and are not counted in the reader's line_num counter."""

  d=get_dialect(dialect)
  r=_reader(iterable,dialect,*args,**kwds)
  for row in r:
    if row and row[0].startswith(d.commentchar):
      # Count only data lines, not comments.
      _reader.line_num-=1
      continue
    yield row
