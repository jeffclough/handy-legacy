#!/usr/bin/env python

import argparse,datetime,csv,json,os,re,sys
from pprint import pprint
# Put a little extra effort into finding our non-standard modules if needed.
try:
  from handy import die,prog
except:
  sys.path.insert(1,os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])),'pylib'))
  sys.path.insert(1,os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])),'lib','python'))
  from handy import die,prog

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Handle the command line.

default_dialect=dict(
  delimiter=',',
  quotechar='"',
  escapechar=None,
  doublequote=True,
  skipinitialspace=False,
  lineterminator='\n',
  quoting=csv.QUOTE_MINIMAL,
)

import OptionParserFormatters
progname=os.path.basename(sys.argv[0])
ap=argparse.ArgumentParser(
  formatter_class=argparse.RawTextHelpFormatter
)
ap.add_argument('-D','--dialect',dest='dialect',action='append',default=[],
help='''Accept any one of the following dialect parameters.
As many -D options may be specified as are needed.
  delimiter=,
  quotechar="
  escapechar=None
  doublequote=True
  skipinitialspace=False
  lineterminator=\\n
  quoting=QUOTE_MINIMAL''')
ap.add_argument('--output-format','-O',dest='output_format',action='store',choices=('csv','json','json-pretty','python'),default='json-pretty',help="Set the output format. (default: %(default)s)")
ap.add_argument('--show-structure','-S',dest='show_structure',action='store_true',default=False,help="Rather than outputting the data itself, just\noutput the structure of the data.")
ap.add_argument('filename',action='store',nargs='?',default=None,help="Name of the file to read JSON data from.")
try:
  opt=ap.parse_args()
except Exception,e:
  print >>sys.stderr,str(e)
  sys.exit(2)

# Set up our dialects.
dialect=dict(default_dialect)
dialect.update(dict(
  [([x.strip() for x in spec.split('=',1)]) for spec in opt.dialect]
))
 
## Validate our field stripping specification.
#for ch in opt.strip:
#  if ch not in 'lr':
#    print >>sys.stderr,'%s: arguments to -s may include only l and r'%progname
#    sys.exit(2)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

def strip_field(s,sides):
  '''Return s stripped of left and/or right white space depending on
  whether sides includes l and/or r.'''

  if type(s) in (str,unicode):
    l='l' in sides
    r='r' in sides
    if l and r:
      s=s.strip()
    elif l:
      s=s.lstrip()
    elif r:
      s=s.rstrip()
  return s

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

norm_color='\033[0m'

def type_description(value):
  "Return a (color,name) tuple representing the type of the given value."

  c='\033['
  t=type(value)
  if t==dict:
    c+='32' # Green
    t='dictionary of %d keys'%len(d.keys())
  elif t==list:
    c+='36' # Cyan
    t='list of %d items'%len(value)
  elif t in (str,unicode):
    c+='33' # Yellow
    t='string of %d characters'%len(value)
  elif t==int:
    c+='1;34' # Bright blue
    t='integer = %d = 0x%x'%(value,value)
  elif t==float:
    c+='35' # Magenta
    t='float = %f'%value
  elif t==bool:
    c+='1;34' # Bright blue
    t='boolean = %s'%value
  elif value==None:
    c+='31' # Red
    t='NULL'
  else:
    c+='0'
    t=str(t)
  return (c+'m',t)

def show_structure(d,indent=0):
  """Show the scructure of the given dictionary as an indented heirarchy."""

  if indent==0:
    c,t=type_description(d)
    print '%s/%s (%s)'%(c,norm_color,t)
    indent+=2

  if not (isinstance(d,dict) or isinstance(d,list)):
    return

  if type(d)==dict:
    for k in sorted(d.keys()):
      c,t=type_description(d[k])
      print '%*s%s%s%s (%s)'%(indent,'',c,k,norm_color,t)
      show_structure(d[k],indent+2)
  elif isinstance(d,list):
    if len(d):
      show_structure(d[0],indent+2)

def time_value(m):
  d=m.groupdict()
  if 'second' not in d:
    d['second']='00'
  if 'am' in d:
    dt=datetime.datetime.strptime("%(hour)s:%(minute)s:%(second)s %(am)s"%d,"%I:%M:%S %p")
  else:
    dt=datetime.datetime.strptime("%(hour)s:%(minute)s:%(second)s"%d,"%H:%M:%S")
  return datetime.time(dt.hour,dt.minute,dt.second)

# A tuple of (NAME,RE,FUNC) triplets for identifying and converting parsable
# types from strings into something more useful.
type_parsers=(
  (
    'int',
    re.compile(r'[-+]?\d+$'),
    lambda m:int(m.group())
  ),
  (
    'float',
    re.compile(r'[-+]?\d+\.\d+([Ee]\d+)?$'),
    lambda m:float(m.group())
  ),
  (
    'time',
    re.compile(r'(?P<hour>\d{1,2}):(?P<minute>\d{1,2})(:(?P<second>\d{1,2}))?\s?(?P<am>([Aa]|[Pp])[Mm]?)?$'),
    time_value
  ),
)

def evaluate(val):
  #print 'D: evaluate(%r)'%(val,)
  if isinstance(val,basestring):
    for name,pat,func in type_parsers:
      m=pat.match(val)
      if m:
        #print 'D: matched %s'%pat.pattern
        val=func(m)
        break
  #print 'D: returning %r'%(val,)
  return val

def traverse(d,func):
  if isinstance(d,dict):
    for key,val in d.items():
      if isinstance(val,(dict,list)):
        traverse(val,func)
      else:
        d[key]=func(val)
  elif isinstance(d,list):
    for i in range(len(d)):
      if isinstance(d[i],(dict,list)):
        traverse(d[i],func)
      else:
        d[i]=func(d[i])

class BetterJsonEncoder(json.JSONEncoder):
  def default(self,obj):
    if isinstance(obj,datetime.time):
      return obj.strftime("%H:%M:%S")
    # Let the base class default method raise the TypeError
    return json.JSONEncoder.default(self, obj)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Read our JSON data.
if opt.filename==None:
  opt.filename='/dev/stdin'
f=open(opt.filename)
d=json.load(f)
f.close()
traverse(d,evaluate) # Parse and convert what values we can.

if opt.show_structure:
  show_structure(d)
  sys.exit(0)
else:
  if opt.output_format=='csv':
    die("Output format csv has not yet been implemented. Please complain to the developer.")
  elif opt.output_format=='json':
    json.dump(d,sys.stdout,cls=BetterJsonEncoder)
  elif opt.output_format=='json-pretty':
    json.dump(d,sys.stdout,indent=2,cls=BetterJsonEncoder)
  elif opt.output_format=='python':
    pprint(d,indent=2,width=prog.term_width)
  else:
    die("Unrecognized output format %s!. Please complain to the developer."%(opt.output_format,))
sys.exit(0)
