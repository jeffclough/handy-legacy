#!/usr/bin/env python3
import os,re,sys
from datetime import datetime,timedelta

from debug import DebugChannel

prog=os.path.basename(sys.argv[0])

def intdivmod(a,b):
  "Like regular divmod(), but returns integers."

  a,b=divmod(a,b)
  return (int(a),int(b))

# Get the character size of this terminal when this module is loaded.
try:
  tty_rows,tty_columns=[int(x) for x in os.popen('stty size','r').read().split()]
except:
  tty_rows,tty_columns=25,80

class ProgressError(Exception):
  "This is the voice of this module when it is displeased."

  def __init__(msg):
    super(ProgressError,self).__init__(msg)

class Progress(object):
  """An object of this class can produce a progress bar as a string when
  str() is applied to it. It must be instantiated with an upper limit,
  and after that, the current position from 0 to this limit may be set
  by calling the object as a function.

  Example:

  finish=17500
  progress=progress.Progress(finish)
  for i in range(finish+1):
    if i%100==0:
      sys.stdout.write('\\r'+str(progress(i)'))
  print '\\r'+str(progress(i))
  """

  def __init__(self,limit,fmt='(%d)',trailer='=',mark='>',leader='-',end='|',width=tty_columns,started=None,strict=True):
    """Initialize this object with its limit and any other optional
    arguments the caller might provide.

    Arguments:
        limit     The upper limit of the pos argument. This must be
                  either an int or float.
        fmt       Format string for the numeric value of this progress
                  bar.
        trailer   Character to fill in the bar to the left of (trailing
                  behind) the current position.
        mark      Character that marks the porgress bar's current
                  position.
        leader    Character to fill in the bar to the right of (leading)
                  the current position.
        end       Character that marks the right side of the bar.
        width     The number of characters to fit the progress bar into.
                  (default: terminal's character width minus 1)
        started   The datetime instance marking when whatever we're
                  monitoring started. If present, this also appends an
                  estimated time until completion to the end of our
                  progress output.
        strict    If True, the position is always forced into the
                  interval [0-limit].
    """

    self.limit=limit
    self.fmt=fmt
    self.trailer=trailer
    self.mark=mark
    self.leader=leader
    self.end=end
    self.width=width
    self.started=started
    self.strict=strict
    self.position=0 # Our start position is 0.

  def __call__(self,pos):
    """Accept a new position for this Progress object and return
    this object."""

    self.position=self.enforceRange(pos)
    return self

  def __str__(self):
    "Output a string describing the state of this Progress object."

    # Get the string version of our position and remember its length.
    pos_str,eta=self.positionString()
    pos_len=len(pos_str)
    eta_len=len(eta)

    # Compute the ideal position of our marker in the width set up for this
    # object, and use this to start building our return value.
    pos=int((self.position/self.limit)*(self.width-eta_len))
    # Crate our trailer position string (if any).
    if pos_str:
      if pos>pos_len:
        s=self.trailer*(pos-pos_len)
      else:
        s=''
      s+=pos_str
    else:
      s=self.trailer*pos
    # Append our position marker if possible.
    if self.mark:
      if not s:
        # Just start with the position marker with no trailer.
        s=self.mark
      else:
        if s[0]==self.trailer:
          # Remove the first leader character and append the position marker.
          s=s[1:]+self.mark
    # Append the leader.
    s+=self.leader*(self.width-eta_len-len(s))
    # Append our end mark if possible.
    if self.end and s[-1] in (self.leader,self.mark):
      s=s[:-1]+self.end
    s+=eta

    # Return our position string.
    return s

  def enforceRange(self,pos):
    "If we're being strict, keep position within [0-limit]."

    if self.strict:
      if pos<0:
        pos=0
      elif pos>self.limit:
        pos=self.limit
    return pos

  def positionString(self,pos=None):
    """Return a tuple containint the the string-formatted value of the
    given position (or by default, current the "position" of this
    instance) of this Progress object and the ETA suffix (or an empty
    string if none)."""

    if pos is None:
      pos=self.position

    # Format our position string.
    if self.fmt:
      try:
        ps=self.fmt%(pos,)
      except TypeError as e:
        if str(e).startswith('not all arguments'):
          ps=self.fmt
        else:
          raise
    else:
      ps=''

    # Format our ETA.
    if self.started:
      # Get our elapsed time in seconds.
      et=datetime.now()-self.started
      et=int(et.days*86400+et.seconds)
      # Compute our time remaining from the rate of our progress so far.
      r=et/pos if et else 1
      s=round(r*(self.limit-pos)) # Estimated seconds remaining.
      days,r=intdivmod(s,86400) # Days
      eta=f"{days}d" if days else ''
      hours,r=intdivmod(r,3600) # Hours
      eta+=f"{hours}h" if hours else ''
      if not days:
        # Minutes
        minutes,r=intdivmod(r,60)
        eta+=f"{minutes}m" if minutes else ''
        if not hours:
          # Seconds are left in r.
          eta+=f"{r}s" if r else ''
    else:
      eta=''

    return (ps,eta)

class PercentProgress(Progress):
  """This is just like the Progress class, but the default format is
  '(%0.0f%%)' and the position in the progress string is expressed as a
  percentage (from 0 to 100) of the limit value."""

  def __init__(self,limit,**kwargs):
    kwargs['fmt']=kwargs.get('fmt','(%0.0f%%)')
    super(PercentProgress,self).__init__(limit,**kwargs)

  def positionString(self,pos=None):
    if pos is None:
      pos=self.position
    return super().positionString(float(pos)/self.limit*100)

class ByteSizeProgress(Progress):
  """This is just like the Progress class, but the default format is
  '(%0.2f %s)' and the position in the progress string is expressed in
  terms of B, KB, MB, GB, TB, EB, ZB, or YB."""

  units=('B','KB','MB','GB','TB','EB','ZB','YB')

  def __init__(self,limit,**kwargs):
    """In addition to requiring a limit argument and accepting all the
    optional arguments of Progress.__init__(), an additional optional
    argument is also accepted:

    divisor   This is the value you divide a number by to convert from
              one unit (like KB) to the next higher unit (like GB). It
              defaults to 1000, but you can set it to 1024 if you're
              counting memory bytes rather than filesystem bytes. These
              are the only two permitted values for the divisor
              artument.
    """

    self.divisor=float(kwargs.get('divisor',1000))
    if self.divisor not in (1000.0,1024.0):
      raise ProgressError("Divisor MUST be either 1000 or 1024.")
    kwargs['fmt']=kwargs.get('fmt','(%0.2f %s)')
    super(ByteSizeProgress,self).__init__(limit,**kwargs)

  def positionString(self,pos=None):
    if pos is None:
      pos=self.position

    _,eta=super().positionString(pos)

    if self.fmt:
      # Figure out which units to use.
      for u in self.units:
        if pos<self.divisor:
          break
        pos/=self.divisor
      else:
        pos*=self.divisor # Because we're at the end of our units.

      try:
        s=self.fmt%(pos,u)
      except TypeError as e:
        if str(e).startswith('not all arguments'):
          s=self.fmt
        else:
          raise
    else:
      s=''
    return (s,eta)

if __name__=='__main__':
  try:
    import argparse
  except:
    import argparse27 as argparse
  try:
    import sys,time

    ap=argparse.ArgumentParser(
      description="Output a progress bar and terminat with 0 (true) if pos < limit. Otherwise, return 1 (false)."
    )
    ap.add_argument('--file',action='store_true',help="""Use the pos and limit arguments as a regular expression and filename, respectively. The position of the line following the first occurance of the regular expression will be use for pos, and the size of the named file will be used for limit.""")
    ap.add_argument('--file-last',action='store_true',help="""Just like --file, but the last occurance of the pattern in the file is used for the position.""")
    ap.add_argument('--newline','-n',action='store_true',help="Write a newline character to standard output after every progress bar. By default, only a carriage return is output, returning the cursor to the left-most column of the terminal.")
    ap.add_argument('--fmt','--format',dest='fmt',action='store',default='(%d)',help="Format string for the numeric value of this progress bar. This option is ignored if --bytes is given. (default: %(default)s)")
    ap.add_argument('--mark',metavar='CHAR',action='store',default='>',help="Character that marks the porgress bar's current position. (default: %(default)s)")
    ap.add_argument('--trailer',metavar='CHAR',action='store',default='=',help="Character to fill in the bar to the left of (trailing behind) the current position. (default: %(default)s)")
    ap.add_argument('--leader',metavar='CHAR',action='store',default='-',help="Character to fill in the bar to the right of (leading) the current position. (default: %(default)s)")
    ap.add_argument('--end',metavar='CHAR',action='store',default='|',help="Character that marks the right side of the bar. (default: %(default)s)")
    ap.add_argument('--width','-w',metavar='W',action='store',type=int,default=tty_columns-1,help="The number of characters to fit the progress bar into. (default: %(default)s)")
    ap.add_argument('--test',metavar='S',action='store',type=float,default=0,help="Write all progress bar values to standard output and exit. The value of this option is the number of seconds (which may be a floating point value) to delay between each iteration.")
    ap.add_argument('--percent',action='store_true',help="Express progress as a percentage rather than as an absolute value.")
    ap.add_argument('--bytes',action='store_true',help="Express progress as a number of bytes in human-friendly units (B, KB, MB, GB, TB, or EB) according to the number of bytes in question.")
    ap.add_argument('--divisor',action='store',type=int,choices=(1000,1024),default=1000,help="For use with --bytes. This is the value you divide a number by to convert from one unit (like KB) to the next higher unit (like GB). It defaults to 1000, but you can set it to 1024 if you're counting memory bytes rather than filesystem bytes. These are the only two permitted values for the divisor artument.")
    ap.add_argument('--started',metavar='T',action='store',help="""T is the time matching the "[[YY]YY-MM-DD ] [HH:MM[:SS]" pattern when the process being monitored was started. The presence of this option turns the ETA at the end of the output value.""")
    ap.add_argument('pos',action='store',help="The position you want this progress bar to express.")
    ap.add_argument('limit',action='store',help="The upper limit of the pos argument.")
    opt=ap.parse_args()

    # If --started is given, parse its argument to a datetime value, and use that
    # together with the current progress position and the current time to
    # estimate the time the process being monitored will finish.
    if opt.started:
      now=datetime.now()
      m=re.match(r'^\s*((?P<year>\d{2,4})[-/](?P<month>\d{1,2})[-/](?P<day>\d{1,2})(\s+|[Tt]))?(?P<hour>\d{1,2}):(?P<min>\d{1,2})(:(?P<sec>\d{1,2}))?\s*$',opt.started)
      if m:
        # Get our time components, make them integers, and put them into an object.
        d=m.groupdict()
        d={k:(None if d[k] is None else int(d[k])) for k in d.keys()}
        opt.started=type('',(),d)

        # Fill in amy missing pieces of our start date and time.
        if opt.started.year is None: opt.started.year=now.year
        elif opt.started.year<100: opt.started.year+=(now.year//100)*100
        elif opt.started.year<1000: opt.started.year+=(now.year//1000)*1000
        if opt.started.month is None: opt.started.month=now.month
        if opt.started.day is None: opt.started.day=now.day
        if opt.started.sec is None: opt.started.sec=0

        # Convert all this to a datetime value.
        opt.started=datetime(
          opt.started.year,opt.started.month,opt.started.day,
          opt.started.hour,opt.started.min,opt.started.sec
        )

    # If --file is given, find the position of the first occurance of the
    # opt.pos RE in the file named by opt.limit.
    if opt.file or opt.file_last:
      if opt.file and opt.file_last:
        print(f"{prog}: Error: You can't use both --file and --file-last. Pick one.",file=sys.stderr)
        sys.exit(1)
      try:
        pat=re.compile(opt.pos)
        filename,opt.limit=opt.limit,os.path.getsize(opt.limit)
        found=0
        with open(filename) as f:
          line=f.readline()
          while line:
            m=pat.search(line)
            if m:
              found=f.tell()
              if opt.file:
                break
            line=f.readline()
        opt.pos=found
      except OSError as e:
        print(f"{prog}: {e}",file=sys.stderr)
        sys.exit(1)
      except Exception as e:
        print(f"{prog}: Error: {e}",file=sys.stderr)
        sys.exit(1)

    try:
      if isinstance(opt.pos,str): opt.pos=float(opt.pos)
      if isinstance(opt.limit,str): opt.limit=float(opt.limit)
    except ValueError as e:
      print(f"{prog}: Error: {e}",file=sys.stderr)
      sys.exit(1)

    if opt.percent:
      p=PercentProgress(
        opt.limit,
        fmt=opt.fmt,
        mark=opt.mark,
        trailer=opt.trailer,
        leader=opt.leader,
        end=opt.end,
        width=opt.width,
        started=opt.started
      )
    elif opt.bytes:
      p=ByteSizeProgress(
        opt.limit,
        #fmt=opt.fmt, <-- Let this class use its default format.
        mark=opt.mark,
        trailer=opt.trailer,
        leader=opt.leader,
        end=opt.end,
        width=opt.width,
        started=opt.started
      )
    else:
      p=Progress(
        opt.limit,
        fmt=opt.fmt,
        mark=opt.mark,
        trailer=opt.trailer,
        leader=opt.leader,
        end=opt.end,
        width=opt.width,
        started=opt.started
      )

    if opt.test>0:
      for i in range(int(opt.limit)+1):
        time.sleep(opt.test)
        sys.stdout.write(str(p(i)))
        if opt.newline:
          sys.stdout.write('\n')
        else:
          sys.stdout.write('\r')
        sys.stdout.flush()
      if not opt.newline:
        sys.stdout.write('\n')
      sys.exit(0)

    sys.stdout.write(str(p(opt.pos)))
    if opt.newline:
      sys.stdout.write('\n')
    else:
      sys.stdout.write('\r')
  except KeyboardInterrupt:
    sys.exit(1)
  if opt.pos<opt.limit:
    sys.exit(0)
  sys.exit(1)
