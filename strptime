#!/usr/bin/env python

import optparse,os,re,sys
from datetime import *
import time as _time

def warn(msg):
  sys.stderr.write(os.path.basename(sys.argv[0])+': '+msg+'\n')

def die(msg,rc=1):
  warn(msg)
  sys.exit(rc)

def delta_seconds(td):
  return td.seconds+td.days*86400

tsnow=_time.time()
now=datetime.fromtimestamp(tsnow)
sametime=timedelta(0)
oneday=timedelta(1)
oneweek=timedelta(7)

class TimeZone(tzinfo):
  # Keep a dictionary of every TimeZone object that's created.
  zones={} # key=time zone name, value=TimeZone instance

  # Remember our local time zone when we see it.
  localtz_offset=int(
    _time.mktime(now.timetuple())-_time.mktime(datetime.utcfromtimestamp(tsnow).timetuple())
  )
  localtz=None
  
  @classmethod
  def byName(cls,tzname):
    """Find and return a class of the given name, ignoring case. If
    none is found, return None."""

    if not tzname:
      tzname=''
    return cls.zones.get(tzname.lower(),cls.localtz)

  def __init__(self,std_name,std_minutes,dst_name,dst_minutes):
    "Initialize this TimeZone object and register its names."

    self.std_name=std_name
    self.std_offset=timedelta(minutes=std_minutes)
    self.dst_name=dst_name
    self.dst_offset=timedelta(minutes=std_minutes+dst_minutes)

    # Register the names of TimeZone instance.
    TimeZone.zones[self.std_name.lower()]=self
    TimeZone.zones[self.dst_name.lower()]=self

    # If we haven't seen our local time zone yet, see if this is it.
    if TimeZone.localtz==None:
      if TimeZone.localtz_offset==delta_seconds(self.utcoffset(datetime.now())):
        TimeZone.localtz=self

  def __del__(self):
    "Remove this dying object from TimeZone.zones."

    del TimeZone.zones[self.std_name.lower()]
    del TimeZone.zones[self.dst_name.lower()]

  def __repr__(self):
    "Return a string that could reconstruct this object."

    return 'TimeZone(%r,%r,%r,%r)'%(
      self.std_name,
      delta_seconds(self.std_offset)/60,
      self.dst_name,
      delta_seconds(self.dst_offset-self.std_offset)/60
    )

  def __str__(self):
    "Return a humanly readable representation of this object's value."

    return self.tzname()

  def utcoffset(self,dt):
    """Return a timedelta object holding the difference from UTC to this
    timezone for the given datetime object (or the current time if dt is
    None)."""

    if self._is_dst(dt):
      o=self.dst_offset
    else:
      o=self.std_offset
    return o

  def tzname(self,dt=None):
    "Return the full name of this TimeZone."

    if dt==None:
      dt=datetime.today()

    o=self.std_offset.days*24+(self.std_offset.seconds/3600)
    if o<0:
      o=-o
    if self.std_name!=self.dst_name:
      #name="%s%d%s"%(self.std_name.upper(),o,self.dst_name)
      #diff=self.dst(dt)
      #name+='(%g)'%((diff.days*86400+diff.seconds)/3600)
      name=self.dst_name
    else:
      name=self.std_name
    return name

  def dst(self,dt=None):
    """Return a timedelta object holding the amount that DST is
    different from standard time IFF dt (or the current time if dt is
    None). Otherwise, return timedelta(0)."""

    if self._is_dst(dt):
      return self.dst_offset-self.std_offset
    else:
      return sametime

  def _is_dst(self,dt=None):
    if dt==None:
      dt=datetime.today()
    #t=dt.timetuple()
    t=(dt.year,dt.month,dt.day,dt.hour,dt.minute,dt.second,0,0,-1)
    t=_time.mktime(t)
    t=_time.localtime(t)
    return t.tm_isdst==1

# Time Zones
tz_us_aleutian=TimeZone('HAST',-10*60,'HADT',60)
tz_us_pacific=TimeZone( 'PST',  -8*60,'PDT', 60)
tz_us_mountain=TimeZone('MST',  -7*60,'MDT', 60)
tz_us_central=TimeZone( 'CST',  -6*60,'CDT', 60)
tz_us_eastern=TimeZone( 'EST',  -5*60,'EDT', 60)
tz_us_atlantic=TimeZone('AST',  -4*60,'ADT', 60)
tz_utc=TimeZone(        'UTC',      0,'UTC',  0)
tz_gmt=TimeZone(        'GMT',      0,'GMT',  0)
tz_eu_western=TimeZone( 'WET',      0,'WEST',60) # Western European Time
tz_eu_central=TimeZone( 'CET',     60,'CEST',60) # Central European Time
tz_eu_eastern=TimeZone( 'EET',   2*60,'EEST',60) # Eastern European Time

# Figure out which one is our local time zone.
#localtz=int(
#  _time.mktime(now.timetuple())-_time.mktime(datetime.utcfromtimestamp(tsnow).timetuple())
#)
#for tz in TimeZone.zones.values():
#  if localtz==delta_seconds(tz.utcoffset(now)):
#    localtz=tz
#    break
#else:

if TimeZone.localtz==None:
  # Kludge for unknown local time zone
  TimeZone('LST',localtz/60,'LDT',60)
  warn('WARNING: Cannot determine local time zone. Using %r'%(TimeZone.localtz,))

# Make our global now variable offset-aware.
now=datetime.now(TimeZone.localtz)

# There should be only one, but ... we have several to choose from.
epochs=dict(
  microsoft=datetime(1,1,1,0,0,0,0,tz_utc),
  ad=datetime(1601,1,1,0,0,0,0,tz_utc),
  cobol=datetime(1601,1,1,0,0,0,0,tz_utc),
  ntfs=datetime(1601,1,1,0,0,0,0,tz_utc),
  vms=datetime(1858,11,17,0,0,0,0,tz_utc),
  ntp=datetime(1900,1,1,0,0,0,0,tz_utc),
  excel=datetime(1900,1,1,0,0,0,0,tz_utc),
  unix=datetime(1970,1,1,0,0,0,0,tz_utc),
)
epoch_names=sorted(epochs.keys())

op=optparse.OptionParser(
  usage="%prog [OPTIONS] arguments expressing date and time"
)
op.add_option('--age',metavar='UNITS',dest='age',choices=('seconds','minutes','hours','days','time'),help="Request the age of the given date and time, and give the desired units (days, hours, minutes, or seconds). The 'time' units value gives an output format of '[-][DAYSd ]%HH:%MM:%SS'. Only integer values are returned, and there is no rounding. Future times return a negative values.")
op.add_option('--youth',metavar='UNITS',dest='youth',choices=('seconds','minutes','hours','days','time'),help="This is exactly like --age above, but the sign of the result is inverted. So future times return a positive values.")
op.add_option('--epoch',dest='epoch',choices=epoch_names,help="Output the number of seconds elapsed from the beginning of given epoch to the given time. Negative values are given for times that predate the epoch. (Epoch choices: %s) The --age option can be used to change the reported epoch value from seconds to something else. And the --youth option will invert the sign of the result in its usual fashion."%(', '.join(epoch_names)))
op.add_option('-f',dest='format',action='store',default='%Y-%m-%d %H:%M:%S',help="Set the output format. See 'man strptime' for the format syntax. (default: %default)")
opt,args=op.parse_args()

if opt.age and opt.youth:
  op.error("The --age and --youth cannot both be used.")

if opt.youth!=None:
  opt.age=opt.youth
  opt.invert=True # Invert --age's result.
else:
  opt.invert=False

if opt.epoch!=None:
  opt.epoch=epochs[opt.epoch]
  if opt.age==None:
    # Because the --age logic is going to do most of --epoch's work.
    opt.age='seconds'

months=(
  'january',
  'february',
  'march',
  'april',
  'may',
  'june',
  'july',
  'august',
  'september'
  'october',
  'november',
  'december'
)

def get_month_by_name(month_name):
  """Return a number from 1 to 12 corresponding to the given month name,
  or return None for an unrecognized month name. To make the caller's
  life easier, any string containing a number from 1 to 12 is also
  returned as the corresponding integer."""

  try:
    n=int(month_name)
    if n>=1 and n<=12:
      return n
    else:
      return none
  except:
    pass
  n=len(month_name)
  if n<3:
    return None
  m=month_name.lower()

  for i in range(len(months)):
    if m==months[i][:n]:
      return i+1
  return None

def beginning_of_day(dt):
  """Return dt with the time components set to midnight."""

  if dt==None:
    return None
  return datetime(dt.year,dt.month,dt.day,0,0,0,0,dt.tzinfo)

def end_of_day(dt):
  """Return dt with the time components set to the last "instant" of
  that day."""

  if dt==None:
    return None
  return datetime(dt.year,dt.month,dt.day,23,59,59,999999,dt.tzinfo)

class ParserBase(object):
  """This is the base class of all other time parsers. Treat it as an
  abstract base class."""

  # This is the name of the format this parser parses.
  name=''

  # This is a sequence of compiled REs. This parser can parse only strings
  # that match one of these REs in their entirety.
  #patterns=(
  #)

  # Parse the given string and return an object representing that time. If
  # the string cannot be parsed, return None.
  def parse(self,time_string):
    return None

class EnglishTimeParser(ParserBase):
  """
  [(this time | end of)] (now | today | tomorrow | yesterday)
  """

  name="English Time Reference"

  def parse(self,time_string):
    # Regualarize whitespace characters in our time string.
    ts=' '.join([s.strip() for s in time_string.split()])

    # We don't care about case.
    ts=ts.lower()

    # Remember whether the called applied a "this time" or "end of" operator.
    this_time=end_of=False
    if ts.startswith('this time '):
      this_time=True
      ts=ts[len('this time '):]
    elif ts.startswith('end of '):
      end_of=True
      ts=ts[len('end of '):]
    dt=datetime.now()

    # See what relative day this phrase expresses.
    if ts in ('this time','now'):
      # A naked "this time" operator also means "now".
      this_time=True # Yes. Even if "this time " is missing.
    elif ts=='today':
      pass # Same as now, but rely on "this time " phrase to keep time of day.
    elif ts=='yesterday':
      dt-=oneday
    elif ts=='tomorrow':
      dt+=oneday
    else:
      dt=None

    # Adjust for "end of" or don't adjust for "this time" operators.
    if end_of:
      dt=end_of_day(dt)
    elif not this_time:
      dt=beginning_of_day(dt)
    return dt

class DateTimeParser(ParserBase):
  """
  YYYY-mm-dd HH:MM:SS [tz]
  [dow] mmm dd hh:mm:ss [tz] yyyy
  [dow] mmm dd hh:mm:ss yyyy [tz]
  """

  name="Full Date and Time"
  patterns=(
    # YYYY-mm-dd HH:MM:SS
    re.compile(
      r'(?P<year>\d+)[-/]'
      r'(?P<month>\d+)[-/]'
      r'(?P<day>\d+)\s+'
      r'(?P<hour>\d+):'
      r'(?P<minute>\d+):'
      r'(?P<second>\d+)'
    ),
    # [dow] mmm dd hh:mm:ss yyyy [tz]
    re.compile(
      r'((?P<dow>\w+)\s+)?'
      r'(?P<month>\w+)\s'
      r'(?P<day>\d+)\s+'
      r'(?P<hour>\d+):'
      r'(?P<minute>\d+):'
      r'(?P<second>\d+)\s+'
      r'((?P<year>\d+)\s+)'
      r'(?P<tz>\w+)?'
    ),
    # [dow] mmm dd hh:mm:ss [tz] yyyy
    re.compile(
      r'((?P<dow>\w+)\s+)?'
      r'(?P<month>\w+)\s'
      r'(?P<day>\d+)\s+'
      r'(?P<hour>\d+):'
      r'(?P<minute>\d+):'
      r'(?P<second>\d+)\s+'
      r'((?P<tz>\w+)\s+)?'
      r'(?P<year>\d+)'
    ),
  )

  def parse(self,time_string):
    for p in self.patterns:
      m=p.match(time_string)
      if m:
        # Load our time components into an untyped object as attributes.
        d=type('',(),m.groupdict())
        d.month=get_month_by_name(d.month)
        if d.month<1:
          continue
        d.day=int(d.day)
        d.hour=int(d.hour)
        d.minute=int(d.minute)
        d.second=int(d.second)
        d.year=int(d.year)
        d.tz=TimeZone.byName(d.tz)
        try:
          dt=datetime(d.year,d.month,d.day,d.hour,d.minute,d.second,0,d.tz)
          return dt
        except ValueError,e:
          die("""Error in "%s", parsed by "%s": %s"""%(time_string,p.pattern,str(e)))
    return None

parsers=(
  DateTimeParser(),
  EnglishTimeParser(),
)

rc=0
if args:
  time_string=' '.join([x.strip() for x in ' '.join(args).split()])
  if time_string=='test':
    print 'Time Zones:'
    for tz in sorted(TimeZone.zones.keys()):
      print TimeZone.zones[tz].tzname()
    sys.exit(0)
else:
  # Use the current time if none is given.
  time_string=str(datetime.today().strftime('%Y-%m-%d %H:%M:%S'))
for p in parsers:
  dt=p.parse(time_string)
  if dt!=None:
    if opt.epoch==None:
      delta=None
    else:
      ##
      ## Handle --epoch, which is really just some pre-processing for --age.
      ##
      #delta=int((dt-opt.epoch).total_seconds())
      delta=delta_seconds(dt-opt.epoch)
    if opt.age!=None:
      ##
      ## Handle --age.
      ##
      if delta==None:
        delta=delta_seconds(now-dt)
      if opt.invert:
        delta=-delta
      if delta<0:
        output='-'
        delta=-delta
      else:
        output=''
      if opt.age=='seconds':
        output+=str(delta)
      elif opt.age=='minutes':
        output+=str(delta/60)
      elif opt.age=='hours':
        output+=str(delta/360)
      elif opt.age=='days':
        output+=str(delta/86400)
      else:
        if delta>=86400:
          output+='%dd '%(delta/86400)
          delta%=86400
        output+='%02d:%02d:%02d'%(delta/3600,(delta%3600)/60,delta%60)
        break
    else:
      ##
      ## Output the reformated time that we've parsed.
      ##
      output=dt.strftime(opt.format)
    break
else:    
  output='unrecognized date/time: %r'%time_string
  rc=1
print output
sys.exit(rc)
