#!/usr/bin/env python

import argparse,fnmatch,os,re,stat,sys
from glob import glob
from handy import file_walker

def non_negative_integer(s):
  try:
    n=int(s)
    if n>=0:
      return n
  except:
    pass
  raise argparse.ArgumentTypeError('%r is not a non-negative integer.'%(s,))

def compile_pattern(s):
  """Return a compled RE for s. If s begins with 're:', the remainder of
  s is the regular expression. Otherwise, s is a filespec and must be
  converted to a regular expression. In either case, the compiled RE is
  returned."""

  if s.startswith('r:'):
    s=s[2:]
  else:
    s=fnmatch.translate(s)
  return re.compile(s)

ap=argparse.ArgumentParser(
  description="Output all filenames not matching any filespec on the command line."
)
ap.add_argument('--path',action='store',nargs='*',default='.',help="One or more paths to search for the filespecs given on the command line.")
ap.add_argument('--recursive','-r',action='store_true',default=False,help="Ordinarilly, only the given paths (with --path) or the current working directory are searched for files not matching those on the command line. This option searches those paths and all subdirectories beneath them.")
ap.add_argument('--depth',type=non_negative_integer,default=sys.maxsize,help="Limit the depth of any recursive search.")
ap.add_argument('--follow',action='store_true',default=True,help="Follow symlinks to directories if recursing.")
ap.add_argument('--prune',nargs='+',action='store',default=[],help="List filespecs and regular expressions (starting with 're:') to specify directories NOT to recurse into.")
ap.add_argument('-v',dest='invert',action='store_true',default=False,help="Invert the function of this command so that only MATCHING files are output.")
ap.add_argument('filespecs',metavar='filespec',nargs='+',action='store',help="These are the filespecs and regular expressions (those starting with 're:') that will be suppressed in the output.")
ap.add_argument('--debug',action='store_true',default=False,help="Enable debugging messages.")
opt=ap.parse_args()

# Use a DebugChannel to stdout for debugging.
from debug import DebugChannel
debug=DebugChannel(enabled=opt.debug,stream=sys.stdout)
debug('opt.path=%r'%(opt.path))
debug('opt.recursive=%r'%(opt.recursive))
debug('opt.depth=%r'%(opt.depth))
debug('opt.follow=%r'%(opt.follow))
debug('opt.prune=%r'%(opt.prune))
debug('opt.invert=%r'%(opt.invert))
debug('opt.filespecs=%r'%(opt.filespecs))

# Compile our filespecs into RE objects.
opt.patterns=[compile_pattern(s) for s in opt.filespecs]
debug('opt.patterns=%r'%([p.pattern for p in opt.patterns],))

def find_match(s,patterns):
  """Return the first RE in patterns that matches s. Return None if no
  match is found."""

  for p in patterns:
    if p.match(s):
      return p
  return None

for p in opt.path:
  debug('p=%r'%(p,))
  for fn in file_walker(p,depth=opt.depth,follow_links=opt.follow,prune=opt.prune):
    debug('fn=%r'%(fn,))
    if bool(find_match(os.path.basename(fn),opt.patterns))==opt.invert:
      print(fn)
    else:
      debug('Rejecting %r'%(fn,))
