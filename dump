#!/usr/bin/env python

import argparse,os,sys
import ansi
from math import ceil,log

col_ctl=str(ansi.Color('yellow on red'))
col_high=str(ansi.Color('bold red on white'))
col_blank=str(ansi.Color('black on blue'))
col_norm=str(ansi.norm)

text='.'

def getTerminalSize():
  "Return a (rows,columns) tuple giving the dimensions of the current terminal."

  log.debug('Running "stty size" ...')
  x,y=([int(x) for x in os.popen('stty size','r').read().split()])
  log.debug('Screen size is %d rows by %d columns.'%(x,y))
  return x,y

def die(msg,stream=sys.stderr):
  stream.write('%s: %s\n'%(ap.prog,msg))
  sys.exit(1)

def read_chunks(f,size):
  """Generator function that returns UP TO size bytes at a time."""

  buf=f.read(size)
  while buf!='':
    # print 'D: read %d bytes from %s'%(len(buf),f.name)
    yield buf
    buf=f.read(size)

def write_byte(f,fmt,val,offset):

  global text
  if offset%4==0:
    f.write('  ')
  else:
    f.write(' ')
  if val==None:
    s=' '*len(fmt%0)
    ch=' '
  else:
    s=fmt%val
    ch=chr(val)
  if opt.color:
    if val==None:
      f.write(col_blank+s+col_norm)
      text+=col_blank+ch+col_norm
    elif val<32:
      f.write(col_ctl+s+col_norm)
      text+=col_ctl+'.'+col_norm
    elif val>126:
      f.write(col_high+s+col_norm)
      text+=col_high+'.'+col_norm
    else:
      f.write(s)
      text+=ch
  else:
    f.write(s)
    if val<32 or val>126:
      text+='.'
    else:
      text+=ch

def dump(inf,base=16,outf=sys.stdout,start=None,stop=None):
  """Write dump information for this file."""

  global text
  # print 'D: dump(%r,base=%r,outf=%r,start=%r,stop=%r)'%(inf.name,base,outf.name,start,stop)

  BUFSIZE=1024 # We'll read this many bytes at a time.
  loc=0     # The file location the most recent buffer was read from.
  bpl=16    # Bytes Per Line of output.

  inf.seek(0,2)
  size=inf.tell() # Remember the size of this file.
  inf.seek(0)
  if start==None: start=0
  if stop==None: stop=size
  if start<0: start=0
  start=(start/bpl)*bpl # Back start up to the beginning of an output line.
  if stop>size: stop=size
  if stop<=start or start>size:
    return # Nothing to do.
  aw=int(ceil(log(size,base))) # Address digits needed for this file.
  if aw<4: aw=4                # But use at least 4 digits, even for small files.
  # print 'D: dump(%r,base=%r,outf=%r,start=%r,stop=%r)'%(inf.name,base,outf.name,start,stop)

  # Set our address and byte format strings and column width according to base.
  afmt,bfmt,cw={
     8:('%%0%do'%aw,'%03o',4),
    10:('%%0%dd'%aw, '%3d',4),
    16:('%%0%dX'%aw,'%02x',3),
  }[base]

  # Start reading the file and dumping the contents.
  for buf in read_chunks(inf,BUFSIZE):
    blen=len(buf) # Get the number of bytes actually read.
    off=0 # We're at the start of this buffer.
    if start>loc+blen:
      # Keep reading chunks until we get the buffer containing the start byte.
      loc+=blen
      continue
    if start>loc:
      # If this chunk contains the start byte, go go straight there.
      off=start-loc
      if (loc+off)%bpl!=0:
        # Fill in the start of this line of output.
        outf.write(afmt%((loc+off)/bpl)*bpl)
        outf.write(blank+(' '*((cw+1)*(loc+off)%bpl))+norm)
        text=blank+(' '*((loc+off)%bpl))+norm
    else:
      off=0
      text=''

    while off<blen:
      if off%bpl==0:
        if loc+off>0:
          # Print any text content from the previous line.
          if text:
            outf.write('  '+text)
            text=''
          # End the previous line with a newline character.
          outf.write('\n')
        # Print the address of this new line.
        addr=((loc+off)/bpl)*bpl
        outf.write(afmt%addr)
      # Here begins the handling of the byte values:
      ch=buf[off]
      val=ord(ch)
      write_byte(outf,bfmt,val,off)
      off+=1
    else:
      # Compute how many bytes short of a line (if any) we are.
      bytes_short=(bpl-((loc+off)%bpl))%bpl
      while bytes_short>0:
        write_byte(outf,bfmt,None,off)
        off+=1
        bytes_short-=1
      outf.write('  '+text)
      loc+=blen

  outf.write('\n')

 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

ap=argparse.ArgumentParser()
ap.add_argument('--base','-b',type=int,choices=(8,10,16),default=16,help="Base for numeric output. (default: %(default)s)")
ap.add_argument('--color','-c',action='store_true',default=False,help="Highlight control characters.")
ap.add_argument('filenames',metavar='file',nargs='+',help="One or more input files to be dumped.")
opt=ap.parse_args()

 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

for fn in opt.filenames:
  try:
    f=open(fn,'rb')
    # print 'D: Opened %s for dumping.'%f.name
    dump(f)
    f.close()
  except IOError,e:
    die('%s: "%s"'%(e.args[1],fn))
