#!/usr/bin/env python

import csv,optparse,os,re,shlex,sys

# ANSI color escape sequences:
attr=dict(
  normal='0',
  bold='1',
  italics='2',
  understore='3',
  reverse='7',
  strikethrough='9',
)
foreground=dict(
  black='30',
  red='31',
  green='32',
  yellow='33',
  blue='34',
  magenta='35',
  cyan='36',
  white='37',
)
background=dict(
  black='40',
  red='41',
  green='42',
  yellow='43',
  blue='44',
  magenta='45',
  cyan='46',
  white='47',
)
norm_color='\033['+attr['normal']+'m'

progname=os.path.basename(sys.argv[0])
def die(msg='',rc=1):
  'Print the message and terminate this process with the given return code.'

  if msg:
    print >>sys.stderr,progname+': '+msg
  sys.exit(rc)

def re_help():
  'Send an excerpt of re.__doc__ to standard output.'

  started=False
  for line in re.__doc__.split('\n'):
    if started:
      if 'This module exports' in line:
        break
      print line
    else:
      if 'Regular expressions can contain both' in line:
        print line
        started=True
  print '''
You can read an expanded treatment of Python's RE syntax at the
following URL:
    http://docs.python.org/library/re.html#regular-expression-syntax
'''

envopts=shlex.split(os.getenv('MARKOPTS','').strip())
if envopts:
  sys.argv[1:1]=envopts

usage='''Usage:
  Form 1: %prog [options] [RE ...]
  Form 2: %prog [options] --columns=COLUMNS
  Form 3: %prog [options] --csv
  Form 4: %prog [options] --fields=FIELDS

Description: The %prog command is a filter (reads from standard input
and writes to standard output) that colors its output using ANSI escape
sequences. Because of this, %prog's output is suitable only for terminal
display. Redirecting %prog's output to a file or to the input of another
command (except for things like the "less" command) will likely yield
unwanted results.

Form 1 of %prog scans each line for any REs (regular expressions) given
as arguments. Any text matching the first RE is colored by the first
palette entry, any text matching the second RE is colored by the second,
and so on. By default, the palette entries are red, green, yellow, bold
blue, magenta, and cyan, all against a black background. The --palette
option can be used to change the list of colors.

By default, the number of REs used from the command line is limited to
the number of entries in the palette. Exceeding this number of REs is
not an error, but text matching the surplus REs will not be colored. Use
the -w option to change this bahavior.

Since %prog is written in Python, Python's regular expression extensions
are available. Python REs are extensions of POSIX EREs, but it uses
Perl-like character classes (e.g. \s and \w) rather than POSIX character
classes (e.g. [:space:] and [:word:], respectively), making REs more
concise. Use --re-help to get a brief lesson in Python REs.

NOTE: Because of how %prog currently handles REs, using the (?...) RE
forms will cause an error. This is a known bug and is on the list of
things to fix.

Forms 2-4 take no RE. They use column or field position to determine the
color of each part of the output, the first field according to the first
palette entry, and so forth.

The MARKOPTS environment variable may be used to supply default command
line options to %prog. Anything found in this variable is processed
before %prog's command line options. The value of MARKOPTS is
interpreted in a shell context, so be sure to quote or escape any white
space. '''
if envopts:
  usage+='''MARKOPTS currently contains:

'''+'\n'.join(['    %s'%x for x in envopts])
else:
  usage+='MARKOPTS is currently empty.'
usage+='''

NOTE: The context options have not yet been implemented!
'''

op=optparse.OptionParser(usage=usage)

op.add_option('-C',dest='comment_mode',action='store_true',default=False,
  help='''Turns on comment mode, which inserts the comment pattern (see --comment) at the start of the pattern list. This marks any line whose first non-space character is '#', which is very commonly a comment line. Use the --comment option to change the pattern used to idententify comments.''')
op.add_option('--columns',dest='columns',action='store',default=None,
  help='''This option turns on fixed-column mode and accepts a comma-separated list of column numbers as its argument. Each given column number identifies the beginning of a column in each line of the input data. This option cannot be used with other highlighting modes. The first column is numbered 1.''')
op.add_option('--comment',dest='comment_format',action='store',default='^\s*#.*',
  help='''Specifies the pattern used to identify comment lines, which is '%default' by default.''')
op.add_option('--after-context',dest='after',action='store',type='int',default=None,
  help='''Print NUM lines of leading context before matching lines. Places a line containing -- between contiguous groups of matches.''')
op.add_option('--before-context',dest='before',action='store',type='int',default=None,
  help='''Print NUM lines of trailing context before matching lines. Places a line containing -- between contiguous groups of matches.''')
op.add_option('--context',dest='context',action='store',type='int',default=None,
  help='''Print NUM lines of leading and trailing context before matching lines. Places a line containing -- between contiguous groups of matches. The context options are only useful in combination whth the --grep option.''')
op.add_option('--csv',dest='csv',action='store_true',default=False,
  help='''For use with -f, this option specifies that the data is in CSV format.''')
op.add_option('-d','--delimiter',dest='delim',default=None,
  help='''For use with -f, this option specifies a regular expression that matches field delimiters. The default is '\s+', which matches one or more whitespace characters.''')
op.add_option('-D','--diff',dest='diff',action='store_true',default=False,
  help='''Turns on diff mode, which colors lines removed differently from lines added.''')
op.add_option('--discard',dest='discard',metavar='RE',action='store',default=None,
  help='''Discards any lines matching the given RE and keeps all others. Discarding lines of CSV data has not yet been implemented. (Cannot be used with --keep.)''')
op.add_option('-f','--fields',dest='fields',action='store',default=None,
  help='''Specifies which fields are to be marked. Field ranges are separated by commas and take the form "m[-[n]]" or "[[m]-]n" where m is the first column in the range (counted from 1) and n is the last. Each field *range* gets its own color. E.g., "-f 1-3,6" says to mark fields 1-3 with the first color in the current palette and to color field 6 with the second. See --csv and -d for data parsing options.''')
op.add_option('-g','--grep',dest='grep',action='store_true',default=False,
  help='''Output only lines that match at least one color filter.''')
op.add_option('-i',dest='ignore_case',action='store_true',default=False,
  help='''Ignore case when matching patterns. This applies both to RE arguments to be matched and to any argument to --discard or --keep.''')
op.add_option('-I','--input',dest='input_from',action='store',choices=('diff','du'),default=None,
  help='''Use sets of pattern known to be helpful for marking the output of certain programs. Valid values are diff and du.''')
op.add_option('--keep',dest='keep',metavar='RE',action='store',default=None,
  help='''Keep any lines matching the given RE and discards all others. Keeping lines of CSV data has not yet been implemented. (Cannot be used with --discard.)''')
op.add_option('--palette',dest='palette',action='store',default='dark',
  help='''Comma-delimited list of color specifications to use to highlight matches for patterns. Each spec is of the form "[ATTR] FG [on BG]" where ATTR is any of bold, italics, underscore, or strikethrough, and FG and BG may be any of black, red, green, yellow, blue, magenta, cyan, or white. Two other possible values for a colorspec can be "normal" and "reverse", which don't make sence with other ATTR, FB, or BG values. You should also know that ATTR, FG, and BG values are persistent from one spec to the next, so, for example "red on black,green,yellow" specifies that matches for the first pattern should be red, second pattern are green, third are yellow, and that all have black backgrounds. Since the palette syntax tends to be verbose, you can also use --palette=dark or --palette=light to use colors generally suitable for dark or light terminal backgrounds, respectively. Since only red, blue, and magenta are used on light backgrounds, using -w is often a good idea with --palette=light. The default setting is "%default".''')
op.add_option('-r','--reverse',dest='reverse',action='store_true',default=False,
  help='''Reverse foreground and background colors of highlighted sections.''')
op.add_option('--re-help',dest='re_help',action='store_true',default=False,
  help='''Display a brief description of Python regular expressions. Then quit.''')
op.add_option('-s','--stanzas',dest='stanzas',action='store_true',default=False,
  help='''In "stanzas" mode, the the RE arguments are matched against input lines. Output lines are colored according to the most recent RE matched. If only one RE is given, output lines will alternate between the first two colors in thte palette every time the input line matches the RE.'''),
op.add_option('-w',dest='wrap',action='store_true',default=False,
  help='''Turn on color wrapping mode. By default, for n colors in the palette, the match for any pattern beyond the nth pattern simply uses the last color in the palette. Wrapping mode changes this behavior so the first color is used for the n+1st pattern, the second for the n+2nd, and so on.''')

#re_columnList=re.compile(r'(?:\s*(\d+)\s*,)*(?:\s*(\d+)\s*)')
re_number=re.compile(r'\d+')

try:
  opt,pat=op.parse_args()
except IOError as e:
  errno,errmsg=e.args
  if errmsg=='Broken pipe':
    sys.exit(1)
  raise
if opt.re_help:
  re_help()
  sys.exit(0)
if opt.ignore_case:
  opt.re_flags=re.I
else:
  opt.re_flags=0
if opt.context!=None:
  if opt.before!=None: opt.before=opt.context
  if opt.after!=None: opt.after=opt.context
if opt.reverse:
  foreground,background=background,foreground
if opt.columns:
  opt.columns=[int(x)-1 for x in re_number.findall(opt.columns)]
  if [x for x in opt.columns if x<0]:
    die('column numbers must be positive integers: %s'%' '.join(['%s'%(x+1) for x in opt.columns]))
  cols=list(opt.columns)
  cols.sort()
  if opt.columns!=cols:
    die('column numbers must be in ascending order: %s'%' '.join(['%s'%(x+1) for x in opt.columns]))
  if opt.columns[0]!=0:
    opt.columns.insert(0,0)
  if opt.fields:
    die('-f (--fields) may not be used with --columns.')
  if pat:
    die('patterns may not be used with --columns')
  if opt.comment_mode:
    die('-C cannot be used with --columns')
  if opt.diff:
    die('-D (--diff) cannot be used with --columns')
  if opt.input_from:
    die('-I (--input) cannot be used with --columns')
  if opt.stanzas:
    die('-s (--stanzas) cannot be used with --columns')
if opt.fields:
  if opt.delim and opt.csv:
    die('-d (--delimiter) cannot be used with --csv')
  if opt.comment_mode:
    die('-C cannot be used with -f (--fields)')
  if opt.diff:
    die('-D (--diff) cannot be used with -f (--fields)')
  if opt.input_from:
    die('-I (--input) cannot be used with -f (--fields)')
  if opt.stanzas:
    die('-s (--stanzas) cannot be used with --fields')
  if not opt.csv and not opt.delim:
    opt.delim=r'\s+'
if opt.comment_mode:
  if opt.diff:
    die('-D (--diff) and -C cannot be used together.')
  pat.insert(0,opt.comment_format)
elif opt.diff:
  pat.insert(0,'^[+>].*')
  pat.insert(0,'^[-<].*')
elif opt.input_from=='diff':
  pat.insert(0,'^[+>].*')
  pat.insert(0,'^[-<].*')
elif opt.input_from=='du':
  pat.insert(0,'^\s*[0-9.]+K') # Blue
  pat.insert(0,'^\s*[0-9.]+G') # Yellow
  pat.insert(0,'^\s*[0-9.]+M') # Green
  pat.insert(0,'^\s*[0-9.]+T') # Red
if opt.discard and opt.keep:
  die('--discard and --keep cannot be used together.')
if opt.discard:
  opt.discard=re.compile(opt.discard,opt.re_flags)
if opt.keep:
  opt.keep=re.compile(opt.keep,opt.re_flags)

if pat:
  for p in pat:
    try:
      x=re.compile(p)
    except re.error as e:
      die('RE error (%s): %r'%(' '.join(e.args),p))
elif not (opt.columns or opt.fields):
  die('No RE arguments given. Nothing to do.')

def complete(word,wordlist):
  'Return a list of words from wordlist that begin with word.'

  return [x for x in wordlist if x.startswith(word)]

def parseColorsFromSpec(spec):
  'Return the (attr,foreground,background) components from the colorspec.'

  # Set up defaults, and lower-case our colorspec.
  a=f=b=None
  spec=spec.lower()

  # Separate the attribute and foreground from the background.
  l=spec.strip().split('on')
  if len(l)>2:
    die('bad colorspec "%s"'%spec)
  if len(l)>1:
    f,b=[x.strip() for x in l]
  else:
    f=l[0]

  # Separate the attribute and foreground.
  l=f.split()
  if len(l)>2:
    die('bad colorspec "%s"'%spec)
  if len(l)>1:
    a,f=l
  elif len(l)==1:
    f=l[0]
  else:
    f=None

  # Complete any partial attribute or color names.
  if a!=None:
    l=complete(a,attr.keys())
    if len(l)<1: die('unknown attribute "%s"'%a)
    if len(l)>1: die('ambiguous attribute "%s"'%a)
    a=l[0]
  if f!=None:
    l=complete(f,foreground.keys())
    if len(l)<1:
      if a==None:
        a,f=f,None
        l=complete(a,attr.keys())
        if len(l)<1:
          die('unknown attribute or foreground color "%s"'%a)
        if len(l)>1:
          die('ambiguous attribute "%s"'%a)
        a=l[0]
      else:
        die('bad colorspec "%s"'%spec)
    elif len(l)>1:
      die('ambiguous foreground color "%s"'%f)
    else:
      f=l[0]
  if b!=None:
    l=complete(b,background.keys())
    if len(l)<1: die('unknown background color "%s"'%b)
    if len(l)>1: die('ambiguous foreground color "%s"'%b)
    b=l[0]

  # Return our triplet of tokens.
  return (a,f,b)

def colorOf(i):
  'Return the ANSI sequence for color of the ith pattern.'

  if opt.wrap:
    i%=len(opt.palette)
  elif i>=len(opt.palette):
    i=-1
  return opt.palette[i]

def parseRangeList(s):
  '''Convert string list of ranges into a list of (n,m) range tuples.'''

  ranges=[x.strip() for x in s.split(',')]
  f=[]
  for r in ranges:
    r=r.split('-')
    if len(r)==1:
      m=int(r[0])
      n=m-1
    else:
      n,m=r
      if n=='':
        n=0
      else:
        n=int(n)-1
      if m=='':
        m=None
      else:
        m=int(m)
    f.append((n,m))
  return f

class DelimitedDataReader(object):
  'Parses fields based on a delimiting regular expression.'

  def __init__(self,stream=sys.stdin,delimiter=r'\s+'):
    'Set our input stream and delimiting regular expression.'

    self.stream=stream
    self.delim=re.compile(delimiter)

  def __iter__(self):
    return self

  def next(self):
    '''Return a list of (field,deliter) pairs for each field and
    terminating delimiter in the next line of input.'''

    s=self.stream.readline()
    if not s:
      raise StopIteration
    if s[-1]=='\n':
      s=s[:-1]
    flist=[]
    m=self.delim.search(s)
    i=0
    while m:
      flist.append([s[i:m.start()],m.group()])
      i=m.end()
      m=self.delim.search(s,i)
    flist.append([s[i:],''])
    return flist

def get_input_lines(f=sys.stdin):
  '''This generator function lets read stdin with a for loop while
  keeping the ability to call sys.stdin.readline(), which is important
  for buffer control reasons. This is also a sensible place to
  implement our --discard and --keep functionality.'''

  s=sys.stdin.readline()
  while s:
    if opt.discard and opt.discard.search(s):
      s=sys.stdin.readline()
      continue
    if not opt.keep or opt.keep.search(s):
      yield s
    s=sys.stdin.readline()

# Convert opt.palette into a list of ANSI escape sequences.
if opt.palette=='dark':
  opt.palette='norm red on black,green,yellow,bold blue,norm magenta,cyan'
elif opt.palette=='light':
  opt.palette='norm red on white,norm blue,magenta'
l=[]
pa,pf,pb='normal','white','black' # Set up defaults for previous values.
for cs in opt.palette.split(','):
  # Get the components of this colorspec, using default from previous spec.
  a,f,b=parseColorsFromSpec(cs)
  if not a: a=pa
  if not f: f=pf
  if not b: b=pb

  # Get the ASCII sequence for this colorspec.
  try:
    l.append('\x1b[%s;%s;%sm'%(attr[a],foreground[f],background[b]))
  except:
    print 'a=%r, f=%r, b=%r'%(a,f,b)
    raise

  # Set up default values for the next colorspec.
  pa,pf,pb=a,f,b
opt.palette=l

if opt.fields:
  if opt.delim:
    opt.delim=re.compile(opt.delim)

if opt.columns:
  # Color each field of our fixed field width data.
  r=range(len(opt.columns))
  opt.columns.append(None)
  for s in get_input_lines():
    try:
      s=(''.join([colorOf(i)+s[opt.columns[i]:opt.columns[i+1]] for i in r])).replace('\n',norm_color)
      print s
      sys.stdout.flush()
    except:
      print 'l=%r'%l
      print 'opt.columns=%r'%opt.columns
      print 's=%r'%s
      print 'i=%r'%i
      raise
elif opt.stanzas:
  # Compile our regular expressions.
  patcount=len(pat)
  if pat: # Combine and compile our patterns into a single regular expression.
    pat=re.compile('|'.join(['(%s)'%x.replace('(','(?:') for x in pat]),opt.re_flags)
  if patcount>1:
    # Assign color based on which RE most recently matched.
    for s in get_input_lines():
      m=pat.search(s)
      if m!=None:
        g=m.groups()
        if g:
          for i in range(len(g)):
            if g[i]!=None:
              break
          sys.stdout.write(colorOf(i))
      sys.stdout.write(s)
      sys.stdout.flush()
    sys.stdout.write(normcolor)
    sys.stdout.flush()
  else:
    # Alternate between first two palette entries every time RE is matched.
    i=1
    for s in get_input_lines():
      m=pat.search(s)
      if m!=None:
        i=1-i
        sys.stdout.write(colorOf(i))
      sys.stdout.write(s)
      sys.stdout.flush()
    sys.stdout.write(normcolor)
    sys.stdout.flush()
elif opt.fields:
  # Highlight fields based on position.
  opt.fields=parseRangeList(opt.fields)
  frange=range(len(opt.fields))
  if opt.delim:
    # Handle space- or custom-delimited data.
    reader=DelimitedDataReader(sys.stdin,opt.delim)
    for flist in reader:
      for i in frange:
	j,k=opt.fields[i]
	for f in range(j,[k,len(flist)][k==None]):
	  if f<len(flist):
	    flist[f][0]=colorOf(i)+flist[f][0]+norm_color
      print ''.join([f+d for f,d in flist])
      sys.stdout.flush()
  else:
    # Handle CSV data.
    reader=csv.reader(sys.stdin)
    writer=csv.writer(sys.stdout)
    for flist in reader:
      for i in frange:
	j,k=opt.fields[i]
	for f in range(j,[k,len(flist)][k==None]):
	  if f<len(flist):
	    flist[f]=colorOf(i)+flist[f]+norm_color
      writer.writerow(flist)
      sys.stdout.flush()
else:
  # Highlight based on RE matching.
  if pat: # Combine and compile our patterns into a single regular expression.
    pat='|'.join(['(%s)'%x.replace('(','(?:') for x in pat])
    try:
      pat=re.compile(pat,opt.re_flags)
    except re.error as e:
      die('Internal RE error (%s): %r'%(' '.join(e.args),pat))

  for s in get_input_lines():
    # Scan each line for matches to our patterns and insert highlighting.
    m=pat.search(s)
    if m!=None or not opt.grep:
      while m:
        g=m.groups()
        if not g:
          break
        for i in range(len(g)):
          if g[i]!=None:
            break
        if opt.comment_mode:
          highlight=colorOf(i+1)
        else:
          highlight=colorOf(i)
        j,k=m.span()
        #print 'j=%d k=%d match=%r'%(j,k,g[i])
        s=s[:j]+highlight+s[j:k]+norm_color+s[k:]
        m=pat.search(s,k+len(highlight)+len(norm_color))
      sys.stdout.write(s)
      sys.stdout.flush()
