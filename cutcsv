#!/usr/bin/env python

import csv,optparse,os,re,sys
import OptionParserFormatters
try:
  import xlrd
  XLRD=True
except:
  XLRD=False

def die(msg,rc=1):
  if msg:
    sys.stderr.write(os.path.basename(sys.argv[0])+': '+msg+'\n')
  sys.exit(rc)

class CsvDialectError(Exception):
  def __init__(self,dialect_spec):
    super(CsvDialectError,self).__init__("Bad CSV dialect specification: %r"%dialect_spec)
    self.dialect_spec=dialect_spec

re_dialect=re.compile(
  '^'
  '(?P<delimiter>.)'
  '(?P<quotechar>.)'
  '(?P<quoting>[amNn])'
  '(?P<doublequote>[ft])'
  '(?P<escapechar>.)'
  '(?P<skipinitialspace>[ft])'
  '$'
)

quoting_map=dict(
  a=csv.QUOTE_ALL,
  m=csv.QUOTE_MINIMAL,
  N=csv.QUOTE_NONNUMERIC,
  n=csv.QUOTE_NONE
)

def parse_dialect(dialect_spec):
  if len(dialect_spec)<len(default_dialect_spec):
    dialect_spec+=default_dialect_spec[-(len(default_dialect_spec)-len(dialect_spec)):]
  m=re_dialect.match(dialect_spec)
  if m==None:
    raise CsvDialectError(dialect_spec)
  d=type('',(),m.groupdict())
  d.quoting=quoting_map[d.quoting]
  d.doublequote=d.doublequote=='t'
  d.skipinitialspace=d.skipinitialspace=='t'
  return d

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Handle the command line.

default_dialect_spec=',"mt\\f'
 
op=optparse.OptionParser(
  formatter=OptionParserFormatters.IndentedHelpFormatterWithNL(2,8),
  usage="%prog [options] [filename] ...",
  description="""
  This program does for CSV files (or Excel files, depending on file extension) what the
  traditional cut command does for more simply delimited data."""
)

op.add_option('-f',dest='fields',action='store',default=None,
help='Output only these fields. FIELDS is made up of one range, or many ranges separated by commas. Each range is one of "N" (the Nth field), "N-" (from the Nth to the last field), "N-M" (from the Nth to the Mth field), or "-M" from the first to the Mth field). Fields are counted beginning with 1, and all ranges are inclusive. By default, all fields are available for output.')

op.add_option('-j',dest='joinfields',action='store',default=None,
help='Join the a givn field range into a single field separated by a single character.')

op.add_option('--no-heading',dest='skip',action='store_const',const=1,default=0,
help="Assume the first line of input contains column headings, and skip over it.")

op.add_option('-o',dest='fmt',action='store',default=None,
help='Specify a format string outputting the fields. Use %1, %2, etc for output. Note that fields excluded by the -f option (if given) are not counted. I.e., If "-f3-5,7" is given, input field 3 becomes output field 1, 4 becomes 2, 5 becomes 3, and 7 becomes 4. In the absence of this option, the output format is CSV.')

op.add_option('--strip',dest='strip',action='store',default='',help="Strip left and/or right whitespace from each parsed field, depending on whether STRIP contains and l and/or r character.")

op.add_option('--vars',dest='vars',action='store',default='',
help="""This option produces output similar to what could be accomplished with the -o option (e.g., -o "name='%1';email='%2';labs='%3';affil='$4'"), but specifying variables this way is simpler, AND the values are safe to use with your shell's eval command. Just give the names of the variables as a list of comma- or space-separated strings, and run eval on the individual lines. (E.g. cutcsv --vars name,email,labs,affil | while read line; do eval "$line"; ... use the variables here ...; done)""")

op.add_option('--reader',dest='reader',action='store',default=default_dialect_spec,
help="""Specify the CSV reader's dialect as SEP[Q[QSTYLE[DQUOTE[ESC[SKIPWS]]]]]. This is a single string of up to five characters:
    SEP: Field separator character. (default: ,)
    Q: Quote character. (default: ")
    QSTYLE: Quoting style. One of 'a' (all), 'm' (minimal, the default), 'N' (non-numeric), or 'n' (none).
    DQUOTE: Represent a literal quote as two consecutive quotes. Either 't' (the default) or 'f'.
    ESC: The escape charater, which makes the next character a literal. (default: \\)
    SKIPWS: Skip whitespace immediately following a field separator. Either 't' or 'f' (the default).""")

op.add_option('--writer',dest='writer',action='store',default=default_dialect_spec,
help="Specify the CSV writer's dialect, using the same syntax as for --reader. (default: %default)")

op.add_option('--worksheet',dest='worksheet',action='store',default=0,
help="""Set the number or name of the worksheet to read from the Excel spreadsheet, assuming we're reading and XLS file.""")

#op.add_option('--debug',dest='debug',action='store_true',default=False,
#help="You don't need this.")

try:
  opt,args=op.parse_args()
except Exception,e:
  print >>sys.stderr,str(e)
  sys.exit(2)

try:
  opt.reader=parse_dialect(opt.reader)
except CsvDialectError as e:
  die("Bad CSV reader dialect: %r"%e.dialect_spec)
except:
  raise

try:
  opt.writer=parse_dialect(opt.writer)
except CsvDialectError as e:
  die("Bad CSV writer dialect: %r"%e.dialect_spec)
except:
  raise

# Validate our field stripping specification.
for ch in opt.strip:
  if ch not in 'lr':
    print >>sys.stderr,'arguments to -s may include only l and r'
    sys.exit(2)

# Turn any list of shell variables we have into a list of variable names.
if opt.vars:
  opt.vars=[var for var in re.split('\W+',opt.vars)]

def parseRangeList(s):
  '''Convert string list of ranges into a list of (n,m) range tuples.'''

  ranges=[x.strip() for x in s.split(',')]
  f=[]
  for r in ranges:
    r=r.split('-')
    if len(r)==1:
      m=int(r[0])
      n=m-1
    else:
      n,m=r
      if n=='':
	n=0
      else:
	n=int(n)-1
      if m=='':
	m=None
      else:
	m=int(m)
    f.append((n,m))
  return f

# Build our range list.
if opt.fields:
  opt.fields=parseRangeList(opt.fields)
else:
  opt.fields=[(0,None)] # The default range list.

# Build our range list of fields to be joined.
if opt.joinfields:
  opt.joinchar=opt.joinchar=opt.joinfields[0]
  opt.joinfields=parseRangeList(opt.joinfields[1:])
  opt.joinfields.reverse() # We join fields from right to left.
else:
  opt.joinfields=[] # The default list.

# Preprocess our format a bit, if one is given.
if opt.fmt:
  opt.fmt=opt.fmt.replace(r'\r','\r').replace(r'\n','\n').replace(r'\t','\t')

def xlsreader(filename,worksheet=0):
  """This is a generator function that returns one row at a time fromt
  the given Excel spreadsheet file. By default, the first worksteet (0)
  is the one that's used."""

  book=xlrd.open_workbook(filename)
  try:
    worksheet=int(worksheet)
  except:
    pass
  if isinstance(worksheet,int):
    try:
      sheet=book.sheet_by_index(worksheet)
    except IndexError:
      print >>sys.stderr,'%s: worksheet %d not found in %s.'%(progname,worksheet,filename)
      sys.exit(1)
  else:
    try:
      sheet=book.sheet_by_name(str(worksheet))
    except xlrd.biffh.XLRDError:
      print >>sys.stderr,'%s: worksheet %r not found in %s.'%(progname,str(worksheet),filename)
      sys.exit(1)
  r=0
  while r<sheet.nrows:
    yield [x.value for x in sheet.row(r)]
    r+=1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

def stripfield(s,sides):
  '''Return s stripped of left and/or right white space depending on
  whether sides includes l and/or r.'''

  l='l' in sides
  r='r' in sides
  if l and r:
    s=s.strip()
  elif l:
    s=s.lstrip()
  elif r:
    s=s.rstrip()
  return s

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Read from standard input if no filename argument was on the command line.
if not args:
  args=['-']

# These characters are escaped when using the --vars option.
re_escape=re.compile(r'''([\\"`$])''')

# Any input file whose name matches this pattern in interpreted as an Excel
# spreadsheet.
re_excel_filename=re.compile(r'\.xls[^.]*$')

# Prepare for CSV output.
writer=csv.writer(open('/dev/stdout','wb'),dialect=opt.writer)

for filename in args:
  if filename=='-':
    filename='/dev/stdin'
  else:
    filename=os.path.expanduser(filename) # Expands '~' to $HOME.
  if re_excel_filename.search(filename):
    if XLRD:
      reader=xlsreader(filename,opt.worksheet)
    else:
      print >>sys.stderr,'%s: Cannot process Excel files without the xlrd module.'%progname
      sys.exit(1)
      
  else:
    reader=csv.reader(open(filename,'rb'),dialect=opt.reader)

  #print 'opt.fields=%r'%opt.fields
  #print 'opt.joinfields=%r'%opt.joinfields
  #if opt.joinfields:
  #  print 'opt.joinchar=%r'%opt.joinchar
  #sys.exit(0)

  input_line=0
  for row in reader:
    # Skip initial lines according to opt.skip.
    input_line+=1
    if input_line<=opt.skip:
      continue

    # Join any field ranges we've been told to.
    for n,m in opt.joinfields:
      row[n:m]=[opt.joinchar.join([x for x in row[n:m] if x])]

    # Make list of only the fields we want to keep.
    fields=[]
    for n,m in opt.fields:
      fields.extend(row[n:m])

    # Apply any stripping options the user specified.
    if opt.strip:
      fields=[stripfield(x,opt.strip) for x in fields]

    # Output the data as the user requested.
    if opt.fmt: # Output formatted field values.
      s=opt.fmt
      field_indices=range(len(fields))
      field_indices.reverse()
      for i in field_indices:
	s=s.replace('%'+str(i+1),fields[i])
      print s
    elif (opt.vars): # Output shell-executable variable assignments.
      fields=[re_escape.sub(r'\\\1',f) for f in fields]
      if (opt.vars)>len(fields): # Protect against initialization issues.
        fields.extend(['']*(len(opt.vars)-len(fields)))
      print ';'.join(['%s="%s"'%(v,f) for v,f in zip(opt.vars,fields)])
    else: # Output CSV.
      writer.writerows([fields])
