#!/usr/bin/env python

import csv,optparse,os,re,sys
try:
  import xlrd
  XLRD=True
except:
  XLRD=False

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Handle the command line.

default_dialect=dict(
  delimiter=',',
  quotechar='"',
  escapechar=None,
  doublequote=True,
  skipinitialspace=False,
  lineterminator='\n',
  quoting=csv.QUOTE_MINIMAL,
)

import OptionParserFormatters
progname=os.path.basename(sys.argv[0])
op=optparse.OptionParser(
  formatter=OptionParserFormatters.IndentedHelpFormatterWithNL(2,8),
  usage="%prog [options] [filename] ...",
  description="""
  This program does for CSV files (or Excel files, depending on file extension) what the
  traditional cut command does for more simply delimited data."""
)

op.add_option('-D','--dialect',dest='dialect',action='append',default=[],
help='''Accept any one of the following dialect parameters. As many -D options may be specified as are needed.

  delimiter=,
  quotechar="
  escapechar=None
  doublequote=True
  skipinitialspace=False
  lineterminator=\\n
  quoting=QUOTE_MINIMAL''')

op.add_option('-R','--read-as',dest='read_as',action='append',default=[],
help='''Accept any one of the following dialect parameters. As many -R options may be specified as are needed.

  delimiter=,
  quotechar="
  escapechar=None
  doublequote=True
  skipinitialspace=False
  lineterminator=\\n
  quoting=QUOTE_MINIMAL''')

op.add_option('-W','--write-as',dest='write_as',action='append',default=[],
help='''Accept any one of the following dialect parameters. As many -W options may be specified as are needed.

  delimiter=,
  quotechar="
  escapechar=None
  doublequote=True
  skipinitialspace=False
  lineterminator=\\n
  quoting=QUOTE_MINIMAL'''
)

op.add_option('-f',dest='fields',action='store',default=None,
help='Output only these fields. FIELDS is made up of one range, or many ranges separated by commas. Each range is one of "N" (the Nth field), "N-" (from the Nth to the last field), "N-M" (from the Nth to the Mth field), or "-M" from the first to the Mth field). Fields are counted beginning with 1, and all ranges are inclusive. By default, all fields are available for output.')

op.add_option('-j',dest='joinfields',action='store',default=None,
help='Join the a givn field range into a single field separated by a single character.')

op.add_option('--no-heading',dest='skip',action='store_const',const=1,default=0,
help="Assume the first line of input contains column headings, and skip over it.")

op.add_option('-o',dest='fmt',action='store',default=None,
help='Specify a format string outputting the fields. Use %1, %2, etc for output. Note that fields excluded by the -f option (if given) are not counted. I.e., If "-f3-5,7" is given, input field 3 becomes output field 1, 4 becomes 2, 5 becomes 3, and 7 becomes 4. In the absence of this option, the output format is CSV.')

op.add_option('-s',dest='strip',action='store',default='',
help="Strip white space from the left and/or right of each field. STRIP may be l, r, lr, or rl. If l is given, white space is be stripped from the left. If r is given, white space is stripped from the right. (Yes, it's rocket science.) By default, no white space is stripped.")

op.add_option('--vars',dest='vars',action='store',default='',
help="""This option produces output similar to what could be accomplished with the -o option (e.g., -o "name='%1';email='%2';labs='%3';affil='$4'"), but specifying variables this way is simpler, AND the values are safe to use with your shell's eval command. Just give the names of the variables as a list of comma- or space-separated strings, and run eval on the individual lines. (E.g. cutcsv --vars name,email,labs,affil | while read line; do eval "$line"; ... use the variables here ...; done)""")

op.add_option('--worksheet',dest='worksheet',action='store',default=0,
help="""Set the number or 
""")

try:
  opt,args=op.parse_args()
except Exception,e:
  print >>sys.stderr,str(e)
  sys.exit(2)

# Set up our dialects.
read_dialect=dict(default_dialect)
read_dialect.update(dict(
  [([x.strip() for x in spec.split('=',1)]) for spec in opt.read_as]
))
write_dialect=dict(default_dialect)
write_dialect.update(dict(
  [([x.strip() for x in spec.split('=',1)]) for spec in opt.write_as]
))
 
# Validate our field stripping specification.
for ch in opt.strip:
  if ch not in 'lr':
    print >>sys.stderr,'arguments to -s may include only l and r'
    sys.exit(2)

# Turn any list of shell variables we have into a list of variable names.
if opt.vars:
  opt.vars=[var for var in re.split('\W+',opt.vars)]

def parseRangeList(s):
  '''Convert string list of ranges into a list of (n,m) range tuples.'''

  ranges=[x.strip() for x in s.split(',')]
  f=[]
  for r in ranges:
    r=r.split('-')
    if len(r)==1:
      m=int(r[0])
      n=m-1
    else:
      n,m=r
      if n=='':
	n=0
      else:
	n=int(n)-1
      if m=='':
	m=None
      else:
	m=int(m)
    f.append((n,m))
  return f

# Build our range list.
if opt.fields:
  opt.fields=parseRangeList(opt.fields)
else:
  opt.fields=[(0,None)] # The default range list.

# Build our range list of fields to be joined.
if opt.joinfields:
  opt.joinchar=opt.joinchar=opt.joinfields[0]
  opt.joinfields=parseRangeList(opt.joinfields[1:])
  opt.joinfields.reverse() # We join fields from right to left.
else:
  opt.joinfields=[] # The default list.

# Preprocess our format a bit, if one is given.
if opt.fmt:
  opt.fmt=opt.fmt.replace(r'\r','\r').replace(r'\n','\n').replace(r'\t','\t')

def xlsreader(filename,worksheet=0):
  """This is a generator function that returns one row at a time fromt
  the given Excel spreadsheet file. By default, the first worksteet (0)
  is the one that's used."""

  book=xlrd.open_workbook(filename)
  try:
    worksheet=int(worksheet)
  except:
    pass
  if isinstance(worksheet,int):
    try:
      sheet=book.sheet_by_index(worksheet)
    except IndexError:
      print >>sys.stderr,'%s: worksheet %d not found in %s.'%(progname,worksheet,filename)
      sys.exit(1)
  else:
    try:
      sheet=book.sheet_by_name(str(worksheet))
    except xlrd.biffh.XLRDError:
      print >>sys.stderr,'%s: worksheet %r not found in %s.'%(progname,str(worksheet),filename)
      sys.exit(1)
  r=0
  while r<sheet.nrows:
    yield [x.value for x in sheet.row(r)]
    r+=1

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

def stripfield(s,sides):
  '''Return s stripped of left and/or right white space depending on
  whether sides includes l and/or r.'''

  l='l' in sides
  r='r' in sides
  if l and r:
    s=s.strip()
  elif l:
    s=s.lstrip()
  elif r:
    s=s.rstrip()
  return s

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Read from standard input if no filename argument was on the command line.
if not args:
  args=['-']

# These characters are escaped when using the --vars option.
re_escape=re.compile(r'''([\\"`$])''')

# Any input file whose name matches this pattern in interpreted as an Excel
# spreadsheet.
re_excel_filename=re.compile(r'\.xls[^.]*$')

# Prepare for CSV output.
writer=csv.writer(open('/dev/stdout','wb'),**write_dialect)

for filename in args:
  if filename=='-':
    filename='/dev/stdin'
  else:
    filename=os.path.expanduser(filename) # Expands '~' to $HOME.
  if re_excel_filename.search(filename):
    if XLRD:
      reader=xlsreader(filename,opt.worksheet)
    else:
      print >>sys.stderr,'%s: Cannot process Excel files without the xlrd module.'%progname
      sys.exit(1)
      
  else:
    reader=csv.reader(open(filename,'rb'),**read_dialect)

  #print 'opt.fields=%r'%opt.fields
  #print 'opt.joinfields=%r'%opt.joinfields
  #if opt.joinfields:
  #  print 'opt.joinchar=%r'%opt.joinchar
  #sys.exit(0)

  input_line=0
  for row in reader:
    # Skip initial lines according to opt.skip.
    input_line+=1
    if input_line<=opt.skip:
      continue

    # Join any field ranges we've been told to.
    for n,m in opt.joinfields:
      row[n:m]=[opt.joinchar.join([x for x in row[n:m] if x])]

    # Make list of only the fields we want to keep.
    fields=[]
    for n,m in opt.fields:
      fields.extend(row[n:m])

    # Apply any stripping options the user specified.
    if opt.strip:
      fields=[stripfield(x,opt.strip) for x in fields]

    # Output the data as the user requested.
    if opt.fmt: # Output formatted field values.
      s=opt.fmt
      field_indices=range(len(fields))
      field_indices.reverse()
      for i in field_indices:
	s=s.replace('%'+str(i+1),fields[i])
      print s
    elif (opt.vars): # Output shell-executable variable assignments.
      fields=[re_escape.sub(r'\\\1',f) for f in fields]
      if (opt.vars)>len(fields): # Protect against initialization issues.
        fields.extend(['']*(len(opt.vars)-len(fields)))
      print ';'.join(['%s="%s"'%(v,f) for v,f in zip(opt.vars,fields)])
    else: # Output CSV.
      writer.writerows([fields])
