#!/usr/bin/env python3
import argparse,os,re,stat,sys
from glob import glob
from debug import DebugChannel

ap=argparse.ArgumentParser(
  usage="""
Form 1: %(prog)s FILESPEC[:[FIRSTLINE][:[LASTLINE]]]
Form 2: %(prog)s FILESPEC[:[STARTPAT][:[ENDPAT]]]""",
  description="""Description:
FIRSTLINE is the number (starting from 1) of the first line to be output. LASTLINE is the number of the last line to be output. If LASTLINE has a plus sign (+) in front of it, it is the number of lines to be output, beginning with FIRSTLINE. If no FIRSTLINE is given, it defaults to 1. If no LASTLINE is given, output continues to the end of the input file.

STARTPAT is a regular expression that, when matched in the input file, starts output. ENDPAT, when matched, ends output. By default, the line matching ENDPAT is included in the output.

Forms 1 and 2 can be mixed, so FILESPEC[:[FIRSTLINE][:[ENDPAT]]] and FILESPEC[:[STARTPAT][:[LASTLINE]]] are also valid arguments. In the latter case, the user is advised to use relative numbering for LASTLINE by prefixing it with a plus sign (+), though this is not required.
"""
)
ap.add_argument('-d',dest='delimeter',action='store',default=':',help="Set the delimiter that separates the components of each command line argument. (default: colon (:))")
#TODO: Implement the -f option.
ap.add_argument('-f','--follow',dest='follow',action='store_true',default=False,help="Monitor the input file for further content if the LASTLINE or ENDPAT is not found. This is similar to the -f option of tail. (NOT YET IMPLEMENTED!)")
ap.add_argument('-i',dest='case',action='store_false',default=True,help="Ignore case when scanning for regular expressions.")
ap.add_argument('-l',dest='filenames',action='store_false',default=True,help="Suppress normal output of filename before slices of that file when more than one file is given.")
# TODO: Implement the --last option.
ap.add_argument('--last',dest='last',action='store_true',default=False,help="Output only the last matching slice in each file. (NOT YET IMPLEMENTED!)")
ap.add_argument('-n','--next',dest='next',action='store_true',default=False,help="Keeps ENDPAT from matching the same line STARTPAT matched. This also requires that the line matching ENDPAT not be output and remain available to be matched by STARTPAT. (This option has no effect if LASTLINE is use rather than ENDPAT, and it makes no sense if FIRSTLINE is used rather than STARTPAT.)")
ap.add_argument('-m','--multi',dest='multi',action='store_true',default=False,help="Output more than one slice per file. Only the first slice is output by default. (This only makes sense if STARTPAT is used.")
ap.add_argument('--debug',action='store_true',help="Turn on debugging output for trouble-shooting purposes.")
ap.add_argument('--test',action='store_true',help="This runs a self-test and is intended for debugging this program. (No output means everything worked correctly.)")
ap.add_argument('args',nargs='*',help="See forms 1 and 2 above under usage.")
opt=ap.parse_args()

dc=DebugChannel(opt.debug,label='D',line_fmt='{label}: {basename}({line}): {indent}{message}\n')

def die(msg,rc=0):
  print(f"{sys.argv[0]}: {msg}",file=sys.stderr)
  sys.exit(rc)

opt.re_flags=0
if not opt.case:
  opt.re_flags|=re.IGNORECASE
re_arg=re.compile(r'(?P<fs>[^%(delimeter)s]+)(%(delimeter)s(?P<first>[^%(delimeter)s]+)?(%(delimeter)s(?P<last>[^%(delimeter)s]+)?)?)?'%opt.__dict__)

def parse_arg(arg):
  """Return a (filespec,start,end,relative) tuple from the given command line
  argument. The filespec may contain wildcards, and start and end may be
  integers, regular expressions, or None. If end was missing, a value of 0 will
  be returned for it. If end is an integer that was preceded by a plus sign in
  the argument, the last element of the tuple will be True.

  >>> m=re_arg.match('testing')
  >>> m==None
  False
  >>> m.group('fs','first','last')
  ('testing', None, None)
  >>> m=re_arg.match('testing:')
  >>> m.group('fs','first','last')
  ('testing', None, None)
  >>> m=re_arg.match('testing::')
  >>> m.group('fs','first','last')
  ('testing', None, None)
  >>> m=re_arg.match('testing:5')
  >>> m.group('fs','first','last')
  ('testing', '5', None)
  >>> m=re_arg.match('testing:5:')
  >>> m.group('fs','first','last')
  ('testing', '5', None)
  >>> m=re_arg.match('testing:5:10')
  >>> m.group('fs','first','last')
  ('testing', '5', '10')
  >>> m=re_arg.match('testing::10')
  >>> m==None
  False
  >>> m.group('fs','first','last')
  ('testing', None, '10')
  >>> parse_arg('testing')
  ('testing', 1, 0, False)
  >>> parse_arg('testing:')
  ('testing', 1, 0, False)
  >>> parse_arg('testing::')
  ('testing', 1, 0, False)
  >>> parse_arg('testing:5:')
  ('testing', 5, 0, False)
  >>> parse_arg('testing:5:10')
  ('testing', 5, 10, False)
  >>> parse_arg('testing::10')
  ('testing', 1, 10, False)
  >>> parse_arg('testing::+10')
  ('testing', 1, 10, True)
  >>> parse_arg('testing:alpha:+10')
  ('testing', re.compile('alpha'), 10, True)
  >>> parse_arg('testing:alpha:beta')
  ('testing', re.compile('alpha'), re.compile('beta'), False)
  >>> parse_arg('testing::beta')
  ('testing', 1, re.compile('beta'), False)
  """

  # Parse the filespec, first, and last components from this argument.
  m=re_arg.match(arg)
  if not m:
    die('Bad argument: %r'%arg)
  fs,first,last=m.group('fs','first','last')
  if not first: first=None
  if not last: last=None
  dc(f"fs={fs!r}, first={first!r}, last={last!r}")
  relative=False
  if first==None:
    first=1
  elif first.isdigit():
    first=int(first)
  else:
    try:
      first=re.compile(first,opt.re_flags)
    except:
      die('Bad regular expression: %s'%first)
  if last==None:
    last=0
  elif last.startswith('+') or last.isdigit():
    if last[0]=='+':
      relative=True
      last=last[1:]
    if not last.isdigit():
      die('Bad numeric value: %s%s'%(('','+')[relative],last))
    last=int(last)
  else:
    try:
      last=re.compile(last,opt.re_flags)
    except:
      die('Bad regular expression: %r'%last)
  return fs,first,last,relative

class FileReader(object):
  """Use this file-like class for reading lines from files while keeping
  track of the current line number and the position from which the
  most recent line was read."""

  def __init__(self,filename):
    """Given the name of the file to read from, initialize this
    FileReader instance."""

    self.file=open(filename)
    self.line_number=0
    self.position=0
    self.eof=False

  def __enter__(self):
    return self

  def __exit__(self,exc_type,exc_value,exc_traceback):
    if exc_value!=None:
      print(exc_type,exc_value,exc_tb,sep="\n",file=sys.stderr)
    return True

  def __iter__(self):
    """When used as an iterator, iterate line by line."""

    while True:
      line=self.readline()
      if line:
        yield line
      else:
        break

  def readline(self):
    """Read and return the next line from our file."""

    self.pos=self.file.tell()
    line=self.file.readline()
    if line:
      self.line_number+=1
    else:
      self.eof=True
    return line

  def rewindOneLine(self):
    """Reposition this file to the beginning of the line most recently
    read from it. Return this FileReader instance."""

    self.file.seek(self.pos)
    self.line_number-=1
    return self

def slice(filename,first,last,relative=False):
  """Read the given file, and output the section from first to last.
  The relative argument is true if last is numeric and expresses
  the number of lines to be returned rather than the ending line number.

  TODO: In order to doctest slice(), we need its stdout. Figure that out.

  #>>> repr(slice(sys.argv[0],1,1))
  #'#!/usr/bin/env python'
  """

  # Initialization and reality checking.
  with FileReader(filename) as f:
    if opt.next and not f.seekable:
      die("Cannot use -n (--next) option with %s because it can't be rewound."%(filename,))
    
    while not f.eof: # In case opt.multi is True.
      # Skip lines until the first line of the slice.
      if isinstance(first,int):
        for line in f:
          if f.line_number>=first:
            break
      else:
        for line in f:
          if first.search(line):
            break
      if not f.eof:
        # Output lines until the end of the slice (or the file).
        sys.stdout.write(line)
        if isinstance(last,int):
          stop=last
          if relative:
            stop+=f.line_number-1
          for line in f:
            if last!=0 and f.line_number>stop:
              break
            sys.stdout.write(line)
            pos=f.tell()
        else:
          if opt.next:
            found=None
          else:
            found=last.search(line)
          while not found:
            for line in f:
              found=last.search(line)
              sys.stdout.write(line)
              if found:
                if opt.next:
                  f.rewindOneLine() # Set up to re-read this line.
                break
        if not opt.multi:
          break

# If the --test option was given, run our internal tests and quit.
if opt.test:
  import doctest
  failed,tested=doctest.testmod(
    optionflags=doctest.ELLIPSIS # Ellipsis matches substrings.
  )
  if failed:
    sys.exit(1)
  sys.exit(0)

# Step through our command line arguments:
for arg in opt.args:
  fs,first,last,relative=parse_arg(arg)
  if fs=='-':
    flist=['/dev/stdin']
  else:
    flist=glob(fs)
  for fn in flist:
    if opt.filenames and (len(opt.args)>1 or len(flist)>1):
      print('\n%s:'%fn)
    slice(fn,first,last,relative)

"""
THIS IS TEST DATA, USED BY THE THIS FUNCTION'S DOCTESTS.

aaa 1
bbb 1
ccc 1
ddd 1

aaa 2
bbb 2
ccc 2
ddd 2
"""
