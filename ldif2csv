#!/usr/bin/env python2
import csv,optparse,os,sys

# Parse command-line arguments
op=optparse.OptionParser(description='Parse LDIF data and reformat as CSV.')
op.add_option('--columns','-c',help='Comma-separated list of attributes to include in CSV output.')
op.add_option('--file','-f',help='LDIF file (default is stdin).')
op.add_option('--output','-o',help='Output file (default is stdout).')
op.add_option('--with-hedings',action='store_true',help='Include a headings row.')
opt,args=op.parse_args()

class LdifError(Exception):
  pass

class LdifEntry(object):
  "This is a ... say it with me ... LDIF entry."

  def __init__(self,data):
    self.dn=self.entry=None
    if isinstance(data,tuple):
      dn,entry=data
    elif isinstance(data,basestring):
      self._from_string(data)
    elif isinstance(data,list):
      self._from_list(data)
    else:
      # data had better be readable like a file.
      self._from_file(data)

  def __nonzero__(self):
    "Return True if this LdifEntry contains data."

    return bool(self.dn and self.entry)

  def _from_seq(self,stanza):
    "Populate this entry from a sequence of strings."

    if len(stanza)==0:
      raise LdifError("Empty stanza cannot create LdifEntry.")
    #print 'D: stansa=%r'%(stanza,)
    if isinstance(stanza[0],basestring):
      # Parse this list of strings.
      self.entry={}
      for line in stanza:
        i=line.find(': ')
        attr=line[:i]
        val=line[i+2:]
        if attr=='dn':
          self.dn=val
        else:
          if attr in self.entry:
            self.entry[attr].append(val)
          else:
            self.entry[attr]=[val]
    elif isinstance(stanza[0],tuple):
      # Parse this list of 2-tuples.
      for attr,val in stanza:
        if attr=='dn':
          self.dn=val
        else:
          if attr in self.entry:
            self.entry[attr].append(val)
          else:
            self.entry[attr]=[val]

  def _from_string(self,s):
    "Populate this entry from the given multi-linie string."

    self._from_list(s.splitlines())

  def _from_file(self,f):
    "Populate this entry from the given open file object."

    stanza=[]
    for line in f:
      # Remove whatever line endings there might be.
      if line and line[-1] in '\r\n': line=line[:-1]
      if line and line[-1] in '\r\n': line=line[:-1]
      if len(line)>0:
        if line[0]==' ':
          if stanza:
            stanza[-1]+=line.lstrip()
          else:
            raise LdifEntry("LDIF continuation line can't be the fist line.")
        else:
          stanza.append(line)
        #print 'D: line=%r'%(line,)
      else:
        break
    if stanza:
      self._from_seq(stanza)

  def __str__(self):
    s='dn: '+self.dn+os.linesep
    attrs=self.entry.keys()
    attrs.sort()
    for attr in attrs:
      s+=''.join(['%s: %s%s'%(attr,val,os.linesep) for val in self.entry[attr]])
    s+=os.linesep
    return s

  def __repr__(self):
    return '%s((%r,%r))'%(self.__class__.__name__,self.dn,self.entry)

def die(msg,rc=1):
  """Write the given message and terminate with the given or default
  return code."""

  sys.stderr.write('%s: %s\n'%(op.prog,msg))
  sys.exit(rc)

# Figure out whether we're reading from stdin or a named file.
if len(args):
  filename=args[0]
  if filename=='-':
    infile=sys.stdin
  else:
    infile=file(filename)
else:
  if not sys.stdin.isatty():
    infile=sys.stdin
  else:
    die('No input found on standard input or as a filename argument.')

# This is a clumsy way to read in our LDIF data, but I'm in a rush.
records=[]
while True:
  rec=LdifEntry(infile)
  if rec:
    records.append(rec)
  else:
    break

# Get or figure out what columns to output.
cols=opt.columns
if cols==None:
  # If the user gave no list of columns to use, list all attributes in
  # alphabetical order, but put dn first.
  s=set([])
  for r in records:
    for a in r.entry:
      if a not in s:
        s.add(s)
  cols=list(s)
  sort(cols)
  cols.insert(0,'dn')

# Now flatten our LDAP objects so we can write them out as CSV data.
out=[]
if opt.with_headings:
  out.append(cols)
for r in records:
  d=dict(r.entry)
  d['dn']=r.dn # A dictionary that includes dn.
  i=dict([(k,0) for k in d]) # Dictionary of attribute value indices.:w
  while i[cols[0]]<len(d[cols[0]):
    out.append([d[c][i[c]] for c in cols])
    # Now incriment i's values in normal counting order ... in the morning.
