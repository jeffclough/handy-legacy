#!/usr/bin/env python2
import csv,optparse,os,re,sys

# Parse command-line arguments
op=optparse.OptionParser(
  usage="%prog [optons] [infile]",
  description='Parse LDIF data from infile or standard input, and reformat it as CSV to standard output (by default).',
  add_help_option=False
)
op.add_option('--columns','-c',help="Comma- and/or space-separated list of case-sensitive attributes to include in CSV output. If this option is not used, all attributes found in the LDIF data will become columns and will arranged alphabetically in the CSV output. Use -h begin output with a row of attribute names.")
op.add_option('--filter',action='append',help="Supply a Python expression that must be true for ever CSV row to be written. As many of these expressions can be supplied as needed, but they must all be true for a given CSV row to be written. The row to be evaluated is in the 'row' list.")
op.add_option('--flatten',action='store_true',help="Flatten multi-valued attributes into as many CSV rows as needed.")
op.add_option('--no-dn',action='store_true',help="Exclude DN from the output columns.")
op.add_option('-h',dest='with_headings',action='store_true',help='Include a headings row. This is strongly encouraged if --columns is not used.')
op.add_option('--help',action='store_true',help=optparse.SUPPRESS_HELP)
opt,args=op.parse_args()

if opt.help:
  op.print_help()
  sys.exit(0)

if opt.columns:
  # Convert comma-separated string to a proper tuple.
  opt.columns=tuple([
    c for c in [
      col.strip() for col in re.split(r'[\s,]+',opt.columns)
    ]
    if c
  ])

class LdifError(Exception):
  pass

class LdifEntry(object):
  "This is a ... say it with me ... LDIF entry."

  def __init__(self,data):
    self.dn=self.entry=None
    if isinstance(data,tuple):
      dn,entry=data
    elif isinstance(data,basestring):
      self._from_string(data)
    elif isinstance(data,list):
      self._from_list(data)
    else:
      # data had better be readable like a file.
      self._from_file(data)

  def __nonzero__(self):
    "Return True if this LdifEntry contains data."

    return bool(self.dn and self.entry)

  def _from_seq(self,stanza):
    "Populate this entry from a sequence of strings."

    if len(stanza)==0:
      raise LdifError("Empty stanza cannot create LdifEntry.")
    #print 'D: stansa=%r'%(stanza,)
    if isinstance(stanza[0],basestring):
      # Parse this list of strings.
      self.entry={}
      for line in stanza:
        i=line.find(': ')
        attr=line[:i]
        val=line[i+2:]
        if attr=='dn':
          self.dn=val
        else:
          if attr in self.entry:
            self.entry[attr].append(val)
          else:
            self.entry[attr]=[val]
    elif isinstance(stanza[0],tuple):
      # Parse this list of 2-tuples.
      for attr,val in stanza:
        if attr=='dn':
          self.dn=val
        else:
          if attr in self.entry:
            self.entry[attr].append(val)
          else:
            self.entry[attr]=[val]

  def _from_string(self,s):
    "Populate this entry from the given multi-linie string."

    self._from_list(s.splitlines())

  def _from_file(self,f):
    "Populate this entry from the given open file object."

    stanza=[]
    for line in f:
      # Remove whatever line endings there might be.
      if line and line[-1] in '\r\n': line=line[:-1]
      if line and line[-1] in '\r\n': line=line[:-1]
      if len(line)>0:
        if line[0]==' ':
          if stanza:
            stanza[-1]+=line.lstrip()
          else:
            raise LdifEntry("LDIF continuation line can't be the fist line.")
        else:
          stanza.append(line)
        #print 'D: line=%r'%(line,)
      else:
        break
    if stanza:
      self._from_seq(stanza)

  def __str__(self):
    s='dn: '+self.dn+os.linesep
    attrs=self.entry.keys()
    attrs.sort()
    for attr in attrs:
      s+=''.join(['%s: %s%s'%(attr,val,os.linesep) for val in self.entry[attr]])
    s+=os.linesep
    return s

  def __repr__(self):
    return '%s((%r,%r))'%(self.__class__.__name__,self.dn,self.entry)

def die(msg,show_help=False,rc=1):
  """Write the given message and terminate with the given or default
  return code. If show_help is true, output our help text."""

  sys.stderr.write('%s: %s\n'%(os.path.basename(sys.argv[0]),msg))
  if show_help:
    sys.stderr.write('\n')
    op.print_help(sys.stderr)
  sys.exit(rc)

# Figure out whether we're reading from stdin or a named file.
if len(args):
  filename=args[0]
  if filename=='-':
    infile=sys.stdin
  else:
    infile=file(filename)
else:
  if not sys.stdin.isatty():
    infile=sys.stdin
  else:
    die('No input found on standard input or as a filename argument.',show_help=True)

# This is a clumsy way to read in our LDIF data, but I'm in a rush.
records=[]
while True:
  rec=LdifEntry(infile)
  if rec:
    records.append(rec)
  else:
    break

# Get or figure out what columns to output.
cols=opt.columns
if not cols:
  # If the user gave no list of columns to use, list all attributes in
  # alphabetical order, but put dn first.
  s=set([])
  for r in records:
    for a in r.entry:
      if a not in s:
        s.add(a)
  cols=list(s)
  cols.sort()
  if not opt.no_dn:
    cols.insert(0,'dn')
#print 'D: cols=%r\n'%(cols,)

# Now flatten our LDAP objects so we can write them out as CSV data.
out=[]
if opt.with_headings:
  out.append(cols)
for r in records:
  d=dict(r.entry)
  d['dn']=[r.dn] # An LDAP dictionary that includes dn.
  for c in cols: # And make sure no attirutes are missing.
    if c not in d:
      d[c]=['']
  i=dict([(k,0) for k in cols]) # Dictionary of current value indices.
  while i[cols[0]]<len(d[cols[0]]):
    row=[d[c][i[c]] for c in cols]
    if opt.filter:
      if all([eval(f) for f in opt.filter]):
        out.append(row)
    else:
      out.append(row)
    # Now incriment i's values in normal counting order ... in the morning.
    for j in range(len(cols)-1,-1,-1):
      k=cols[j]
      i[k]+=1
      if j>0 and i[k]>=len(d[k]):
        # Wrap index back around to zero for all but the left-most column.
        i[k]=0
      else:
        break

# Output our flattened data as CSV.
writer=csv.writer(sys.stdout)
writer.writerows(out)
