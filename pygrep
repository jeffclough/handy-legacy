#!/usr/bin/env python

import optparse,os,re,sys

if sys.version_info<(2,4):
  # We'll need to supply our own reversed() function.

  def reversed(seq):
    """Return a reversed copy of the given sequence as a list. This
    isn't an exact replacement for version 2.4's reversed() built-in
    function, but it's just fine for the needs of this script."""

    l=list(seq)
    l.reverse()
    return l

progname=os.path.basename(sys.argv[0])

format_fieldspec=re.compile(r'{([0-9A-Za-z_]*)}')
def format(fmt,*args,**kwargs):
  #print '---- args=%r, kwargs=%r'%(args,kwargs)
  # Get a list of fields in the format string: (start,end,id) tuples
  fields=[]
  i=0 # Empty fieldspecs ({}) will begin with field number 1.
  for m in format_fieldspec.finditer(fmt):
    id=m.group(1)
    if len(id)==0:
      i+=1
      id=i
    elif id.isdigit():
      i=id=int(id)
    else:
      i=len(fields)+1
    fields.append((m.start(),m.end(),id))
  for start,end,ndx in reversed(fields):
    if isinstance(ndx,int):
      if ndx>=0 and ndx<=len(args):
        fmt=fmt[:start]+args[ndx]+fmt[end:]
      else:
        fmt=fmt[:start]+fmt[end:]
    else:
      fmt=fmt[:start]+kwargs.get(ndx,'')+fmt[end:]
  return fmt

def grepfile(filename,r):
  '''Search the given file (or stdin if filename is '-') for lines that
  match the given regular expression. Return the number of matching
  lines.'''

  # Open our input file as inf.
  if filename=='-':
    filename='(standard input)'
    inf=sys.stdin
  else:
    try:
      inf=open(filename)
    except Exception,e:
      print >>sys.stderr,'%s: Error opening file %s: %s'%(progname,filename,e)
      return 0

  # Scan inf for matchine lines and handle them according to our global
  # options.
  matches=0
  linecount=0
  for line in inf:
    linecount+=1
    if line and line[-1]=='\n':
      line=line[:-1]
    if opt.match:
      m=r.match(line)
    else:
      m=r.search(line)
    if (m!=None)!=opt.invert:
      matches+=1
      if opt.list:
	if opt.number:
          continue
        break
      if opt.format:
        try:
          line=format(opt.format,*((m.group(),)+m.groups()),**m.groupdict())
        except AttributeError,e:
          print 'opt.format=%r (type=%s)'%(opt.format,type(opt.format))
          msg=str(e)
          sys.stdout.flush()
          sys.stderr.write('%s: %s(%d): %s\n'%(progname,filename,linecount,msg))
          raise
          exit(2)
        except IndexError,e:
          msg=str(e)
          sys.stdout.flush()
          sys.stderr.write('%s: %s(%d): %s\n'%(progname,filename,linecount,msg))
          exit(2)
        except ValueError,e:
          msg=str(e)
          sys.stdout.flush()
          sys.stderr.write('%s: %s(%d): %s\n'%(progname,filename,linecount,msg))
          exit(2)
      if opt.number:
	if opt.onefile:
	  print '%d:%s'%(linecount,line)
	else:
	  print '%s:%d:%s'%(filename,linecount,line)
        if m:
          if opt.groups and m.groups():
            print '('+')('.join(['%s'%repr(x) for x in m.groups()])+')'
          if opt.groups=='dict' and m.groupdict():
            d=m.groupdict()
            print ' '.join(['%s=%s'%(x,repr(d[x])) for x in d])
          if opt.groups:
            print ''
      else:
	if opt.onefile:
	  print line
	else:
	  print '%s:%s'%(filename,line)
        if m:
          if opt.groups and m.groups():
            print '('+')('.join(['%s'%repr(x) for x in m.groups()])+')'
          if opt.groups=='dict' and m.groupdict():
            d=m.groupdict()
            print ' '.join(['%s=%s'%(x,repr(d[x])) for x in d])
          if opt.groups:
            print ''
  if opt.list and matches>0:
    if opt.number:
      print '%s:%d'%(filename,matches)
    else:
      print filename
  return matches

# Handle our command line.
import OptionParserFormatters
usage="%prog [options] [filename] ..."
description="""While this command may be generally useful, its primary purpose is as a tool for experimenting with Python's regular expression syntax. Briefly, it searches the named input files (or standard input if no files are named, or the file name - is given) for lines containing a match to the given pattern. By default, the matching lines are printed. """
epilog="""
 Exit
Status  Comments
   0    No errors. At least one match was found.
   1    No errors. No match was found.
   2    An error was detected in the regular expression syntax or in the
        command line options.
   3    There was a problem opening or reading a file.

Note that the -v option reverses the meanings of status codes 0 and 1."""

if sys.version_info<(2,5):
  op=optparse.OptionParser(
    formatter=OptionParserFormatters.IndentedHelpFormatterWithNL(2,8),
    usage=usage,
    description=description+'\n'+epilog
  )
else:
  op=optparse.OptionParser(
    formatter=OptionParserFormatters.IndentedHelpFormatterWithNL(2,8),
    usage=usage,
    description=description,
    epilog=epilog
  )
op.add_option('-f','--format',dest='format',action='store',default=None,help="""Format matching lines (or non-matching lines if -v is also used) according to the given FORMAT. FORMAT is a Python formatting string as described in 7.1.3 of the Python Standard Library documentation. Briefly, all brace expressions ({}) are replaced by either positional or named groups within the matched regular expression. You can leave the braces empty to let the formatter do the counting for you (e.g. '{} then {}' is the same as '{0} then {1}'). If the matched RE uses named groups (e.g. '(?P<age>\d+) (?P<lname>[^,]+),(?P<fname>.*)'), then the FORMAT string can refer to what those groups match (e.g. '{fname} {lname} is {age} years of age.').""")

op.add_option('-1',dest='onefile',action='store_true',default=False,help="Matching lines are normally prefixed with the filename followed by a colon when more than one filename is given on the command line. When only one filename is given, this prefix is omitted. This option tells %prog to behave as if only one file were given regardless of how many were actually given. (default: %default)")

op.add_option('--flag',dest='flags',action='store',default=None,help="""Use as many of the following as you'd like to set the Python regular expression options:
  i - Ignore case. (Same as -i option.)
  l- Make \w, \W, \\b, \B, \s, and \S dependent on current locale.
  m - Operate in multiline mode. ^ and $ recognize embedded newlines.
  s - Make the . special character recognize newlines as well as other white space.
  u - Make \w, \W, \\b, \B, \s, and \S respect the Unicode properties database.
  x - This flag allows you to write regular expressions that look nicer.  Whitespace within the pattern is ignored, except when in a character class or preceded by an unescaped backslash, and, when a line contains a "#" neither in a character class or preceded by an unescaped backslash, all characters from the leftmost such "#" through the end of the line are ignored.
Combine these flags as you'd like, e.g. --flags=ims.""")
op.add_option('--flags',dest='flags',action='store',default=None,help="Same as --flag.")

op.add_option('-g',dest='groups',action='store_const',const='tuple',default=None,help="Show the tuple of matching groups for each matching line.")
op.add_option('-G',dest='groups',action='store_const',const='dict',default=None,help="Show the dictionary of matching named groups for each matching line.")

op.add_option('-i',dest='ignore_case',action='store_true',default=False,help="Ingore case. (Same as --flag=i.)")

op.add_option('-l',dest='list',action='store_true',default=False,help="Suppress normal output; instead print the name of each input file from which no output would normally have been printed. The scanning will stop on the first match. If -n is used with -l, the number of matches in each file is given after the filename, with a colon separating them.")

op.add_option('-m',dest='match',action='store_true',default=False,help="Use the match() function rather than the search() re class method. To over-simplify, match() only finds matches at the beginning of a line, while search() will scan the whole line for at match anywhere within it.")

op.add_option('-n',dest='number',action='store_true',default=False,help="Prefix each line of output with the line number within its input file. See -l for how it modifies -n's behavior.")

op.add_option('-v',dest='invert',action='store_true',default=False,help="Invert the sense of matching so that non-matching lines are selected.")

opt,args=op.parse_args()
flags=0
if opt.flags:
  for f in opt.flags:
    if f=='i':
      flags|=re.IGNORECASE
    elif f=='l':
      flags|=re.LOCALE
    elif f=='m':
      flags|=re.MULTILINE
    elif f=='s':
      flags|=re.DOTALL
    elif f=='u':
      flags|=re.UNICODE
    elif f=='x':
      flags|=re.VERBOSE
    else:
      print >>sys.stderr,'%s: Invalid flag character: "%s"'%(progname,f)
      exit(2)
if opt.ignore_case:
  flags|=re.IGNORECASE
opt.flags=flags

matches=0
try:
  # Compile our regular expression.
  if not args:
    print >>sys.stderr,'%s: Missing regular expression'%progname
    exit(2)
  try:
    r=re.compile(args[0],opt.flags)
  except Exception,e:
    print >>sys.stderr,'%s: %s'%(progname,e)
    exit(2)
  del args[0]

  # Scan the given files (or stdin) for our regular expression.
  if not args:
    args=['-']
  if not opt.onefile and len(args)==1:
    opt.onefile=True
  for filename in args:
    matches+=grepfile(filename,r)

except IOError,e:
  if 'broken pipe' not in str(e).lower():
    raise

# Terminate with an exit status of 0 if found a match. Otherwise, terminate
# with an exit status of 1.
sys.exit(int(matches<1))
