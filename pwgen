#!/usr/bin/env python

import base64,optparse,random,re,string,sys
try:
  from OptionParserFormatters import IndentedHelpFormatterWithNL
except:
  IndentedHelpFormatterWithNL=optparse.IndentedHelpFormatter

 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Set up and handle the command line.

# Define some password rule sets, marking one of them as the default, and
# remember which one that is.
rule_sets=dict(
  default=dict( # This is the default, general-purpose, rule set.
    binary=None,
    base64=False,
    classes='Aa1',
    dictionary=False,
    min_length=11,
    max_length=15,
    capitalize=False,
    default=True
  ),
    gt=dict( # For working with GT account holders.
      binary=None,
      base64=False,
      classes='a1',
      dictionary=False,
      min_length=11,
      max_length=11,
      capitalize=True
    ),
    iam=dict( # For IAM connectivity password values.
      binary=8,
      base64=True,
      classes=None,
      dictionary=False,
      min_length=16,
      max_length=32,
      capitalize=False
    ),
    guest=dict( # For guest password values.
      binary=None,
      base64=False,
      classes='Aa1',
      dictionary=True,
      min_length=11,
      max_length=22,
      capitalize=False
    )
)
rule_set_names=tuple(sorted(rule_sets.keys()))
default_rule_set=None
for rsn,rs in rule_sets.items():
  if rs.get('default'):
    default_rule_set=rsn
rules=type('',(),rule_sets[default_rule_set])

op=optparse.OptionParser(
  formatter=IndentedHelpFormatterWithNL(2,8),
  usage='''\
  %prog [options] [N]

Description:
  This command produces a single string of random characters according to the
  options given and writes it to standard output. Such strings are useful as
  passwords.
  
  If the N argument is given, that number of random strings will be output,
  one per line. Otherwise, a single password will be output.
'''
)

op.add_option('--base64',dest='base64',action='store_true',default=rules.base64,help='Encode the password as base64 and output it after the plaintext password.')
op.add_option('--bin',dest='binary',action='store_const',const=8,default=rules.binary,help="Generate a binary password of 8-bit characters. You should redirect output to a file and/or use the --base64 option above to avoid spewing random binary crap to your terminal with this option.")
op.add_option('--bin16',dest='binary',action='store_const',const=16,default=rules.binary,help="Generate a binary password of 16-bit characters. You should redirect output to a file and/or use the --base64 option above to avoid spewing random binary crap to your terminal with this option.")
op.add_option('-c','--capitalize',dest='capitalize',action='store_true',default=rules.capitalize,help="Capitalize ONLY the first character of the generated password, which incidently forces the first character to be an alphabetic character. (default: %default)")
op.add_option('--classes',dest='classes',action='store',default=rules.classes,help="""The CLASSES value, which defaults to \"%default\", should contain one character from each character class (lower case, upper case, numerals, and punctuation) that must appear in the generated string.

The format of this option's argument is '(C[{N[,M]}]) ...'. C is a character from the desired characer class (e.g. A-Z for upper case, 0-9 for digits, etc.), N is the minimum number of caracters from from that class (defauls to 1), and M is the maximum number (defaults to --max's value). The (, [, ], and ) are the usual BNF syntax elements. If {N[,M]} is not given, N defaults to 1, and M defauls to --max's value. For example, an argument of Aa9: is the same as Aa9{1}:{1}, but you can use Aa9{1,1}:{1,1} to require at least one and allow no more than one digit and punctuation (each) in a generated password.""")
op.add_option('-d','--dictionary',dest='dictionary',action='store_true',default=rules.dictionary,help="Use the system dictionary to compose the random password.")
op.add_option('-m','--min',dest='min_length',type='int',action='store',default=rules.min_length,help="Minimum length of the generated random string. (default: %default)")
op.add_option('-M','--max',dest='max_length',type='int',action='store',default=rules.max_length,help="Maximum length of the generated random string. (default: %default)")
op.add_option('-r','--rules',dest='rules',action='store',choices=rule_set_names,default=None,help="Specify what preset password rules (choose from  to apply when generating passwords, obviating any other options that might be given before or after this one.")
opt,args=op.parse_args()

# Apply any rule set that may have been given.
if opt.rules:
  for o,v in rule_sets[opt.rules].items():
    setattr(opt,o,v)

# Ensure that max_length>=min_length.
if opt.min_length>opt.max_length:
  opt.max_length=opt.min_length

# If we're capitalizing only the first character of the password, ensure
# that our character classes exclude upper-case characters.
if opt.capitalize:
  opt.classes=filter(lambda c:not c.isupper(),opt.classes)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

if opt.dictionary:
  # Find our word list on disk.
  dfiles=['/usr/share/dict/words','/usr/share/lib/dict/words']
  while len(dfiles)>0:
    fn=dfiles.pop(0)
    try:
      f=open(fn,'r')
      break
    except:
      if len(dfiles)>0:
        continue
      raise RandomString.Error('Cannot find dictionary (words) file on disk.')
  # Get a list of lower-case words without funny characters and
  # with a length from 5 to 8 characters.
  words=[
    x for x in [w.strip() for w in f]
      if 5<=len(x)<=8 and x.islower() and x.isalpha()
  ]
  # Clean up our housekeeping variables.
  del f,fn,dfiles

# Supply an all(seq) function if we don't have one.
try:
  all
except NameError:
  def all(seq):
    "Implement the all() built-in function intruduced in Python 2.5."

    for x in seq:
      if not x:
        return False
    return True

# Supply an any(seq) function if we don't have one.
try:
  any
except NameError:
  def any(seq):
    "Implement the any() built-in function intruduced in Python 2.5."

    for x in seq:
      if x:
        return True
    return False

# Supply a Set class and set() function if we don't have them.
try:
  set
except NameError:
  class Set(object):
    """This is a very partial replacement for the set type introduced in
    Python 2.4"""

    def __init__(self,seq):
      "Initialize this set with the items in the given sequence."

      self.d={} # We'll fake a set with the keys of a dict.
      for val in seq:
        self.d[val]=None

    def __len__(self):
      "Return the number of items in this set."

      return len(self.d)

    def __contains__(self,val):
      "Return True if val is in this set."

      return val in self.d

    def __repr__(self):
      return 'set(['+', '.join([repr(val) for val in self.d.keys()])+'])'

    def __str__(self):
      return repr(self)

    def add(self,val):
      "Add the value to our set."

      self.d[val]=None

    def remove(self,val):
      "Remove the value from our set. Raise KeyError if there's no such value."

      del self.d[val]

  def set(seq):
    "Return a new set containing the elements of the given sequence."

    s=Set(seq)
    return s


# Cook up some character class data based on the user's options.
class RandomString(object):

  class Error(Exception):
    'RandomString objects complain with this exception type.'

    pass

  class CharacterClass(object):
    cc_strings=(
      '9012345678',
      'abcdefghijklmnopqrstuvwxyz',
      'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
      '-!@#$%^&*()=_+~[]{}|;:,./<>?', # I've left out backslash and all quotes.
      ' '
    )
    classes=[] # This is a list of all CharacterClass instances.

    def __init__(self,sample,min_count,max_count):
      self.members=None
      for cc_members in RandomString.CharacterClass.cc_strings:
        if sample in cc_members:
          self.members=cc_members
          break
      if self.members==None:
        raise RandomString.Error("Bad Character class sample: %r"%sample)
      self.min_count=min_count
      self.max_count=max_count
      self.resetCount()
      RandomString.CharacterClass.classes.append(self)

    def isalpha(self):
      "Return True iff this character class holds alphabetic characters."

      return self.members.is_alpha()

    def name(self):
      "Return the name of this character class."

      if self.members:
        return self.members[0]
      return None

    def getCharacter(self):
      """Return a random character from this CharacterClass unless we're
      maxed out."""

      if self.count>=self.max_count:
        return None
      self.count+=1
      return random.choice(self.members)

    def resetCount(self):
      "Reset this CharacterClass's count to 0."

      self.count=0

  ccspec=re.compile(r'((.)(?:{(\d+)(?:,(\d+))?})?)')

  def __init__(self,character_classes='A{1}a{10}9',min_length=None,max_length=None):
    'Set up this character class according to the given spec.'

    # Create the CharacterClass objects according to the caller's spec.
    for spec,ch,min_count,max_count in RandomString.ccspec.findall(character_classes):
      #print 'D: spec=%r ch=%r min_count=%r max_count=%r'%(spec,ch,min_count,max_count)
      if min_count=='':
        self.min_count=1
      else:
        try:
          self.min_count=int(min_count)
        except:
          raise RandomString.Error('Bad character class spec: %r: %r is not an integer'%(spec,min_count))
      if max_count=='':
        self.max_count=self.min_count
      else:
        try:
          self.max_count=int(max_count)
        except:
          raise RandomString.Error('Bad character class spec: %r: %r is not an integer'%(spec,max_count))
      #print 'D: self.min_count=%r self.max_count=%r'%(self.min_count,self.max_count)
      if self.max_count<self.min_count:
        raise RandomString.Error('Bad character class spec: %r: %d<%d'%(spec,min_count,max_count))
      cc=RandomString.CharacterClass(ch,self.min_count,self.max_count)
      if not cc.name():
        raise RandomString.Error('Bad character class spec: %r: invalid character: %r'%(spec,ch))

    # Give min_length a workable value if not supplied by the caller.
    l=sum([cl.min_count for cl in RandomString.CharacterClass.classes])
    if min_length==None or min_length<l:
      min_length=l
    self.min_length=min_length

    # Give max_length a workable value if not supplied by the caller.
    l=sum([cl.max_count for cl in RandomString.CharacterClass.classes])
    if max_length==None:
      max_length=l
    if max_length<min_length:
      max_length=min_length
    self.max_length=max_length

  def isValid(self,candidate):
    """Return True iff the given string matches what we've been told to
    generate."""

    # Validate overall string length.
    if len(candidate)<self.min_length or len(candidate)>self.max_length:
      return False

    # Validate number of instances of each character class.
    for cl in RandomString.CharacterClass.classes:
      l=len(filter(lambda ch:ch in cl.members,candidate))
      if l<cl.min_count or l>cl.max_count:
        return False

    return True

  def __call__(self,mode='random'):
    if mode=='random':
      pw=str(self)
    else:
      pw=''
      if mode.startswith('binary'):
        # Generate an 8- or 16-bit binary password.
        if mode=='binary16':
          pw=u''.join([
            unichr(random.randint(0,65535))
              for x in range(random.randint(opt.min_length,opt.max_length))
          ])
        else:
          pw=''.join([
            chr(random.randint(0,255))
              for x in range(random.randint(opt.min_length,opt.max_length))
          ])
      elif mode=='dictionary':
        nac=0 # Used as an index to non_alpha_classes.
        while True:
          # Choose a random word from the dictionary.
          w=random.choice(words)
          # If we're using capital letters, capitalize each word.
          if 'A' in chars:
            w=w.capitalize()
          # If we're going to need another word, and if we're using non-
          # alpha character classes, use characters from those classes
          # to separate words.
          pw+=w
          l=len(pw)
          if l<opt.min_length:
            if len(non_alpha_classes):
              pw+=random.choice(non_alpha_classes[nac])
              nac=(nac+1)%len(non_alpha_classes)
          else:
            # Validate length and character classe compliance.
            if l<=opt.max_length or all([any([ch in pw for ch in cl]) for cl in classes]):
              break # pw holds a valid password.
            # Otherwise, start over.
            pw=''
            nac=0
          #print 'w=%r pw=%r'%(w,pw)
        if opt.capitalize:
          pw=pw.capitalize()
      else:
        raise RandomString.Error('Bad mode: %r: invalid character: %r'%(spec,ch))
    return pw

  def __str__(self):
    "Return a random string."

    while True:
      # Reset our character class counts.
      for cl in RandomString.CharacterClass.classes:
        cl.resetCount()
      # Choose a random string length within our range.
      l=random.randint(self.min_length,self.max_length)
      # Always begin with a caracter from the first character class.
      rs=RandomString.CharacterClass.classes[0].getCharacter()
      while len(rs)<l:
        ch=random.choice(RandomString.CharacterClass.classes).getCharacter()
        if ch!=None:
          rs+=ch
      if self.isValid(rs):
        break
      #print 'D: Rejecting %r'%(rs,)
    return rs
    

class_n='0123456789'
class_l='abcdefghijklmnopqrstuvwxyz'
class_u='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
class_p='!@#$%^&*()-=_+~[]{}|;:,./<>?' # I've left out backslash and all quotes.
class_s=' '
classes=[class_n,class_l,class_u,class_p,class_s]
for i in range(len(classes)-1,-1,-1):
  if not any([ch in classes[i] for ch in opt.classes]):
    del classes[i]
if opt.max_length<len(classes):
  print >>sys.stderr,'For %d character classes, a maximum length of %d is too short!'%(len(classes),opt.max_length)
  sys.exit(1)
chars=''.join(classes)
non_alpha_classes=[
  s for s in (class_n,class_p,class_s)
    if any([ch in s for ch in opt.classes])
]

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

if len(args)>0:
  try:
    N=int(args[0])
  except:
    print >>sys.stderr,"The N argument must be an integer value."
    sys.exit(1)
else:
  N=1

randstr=RandomString()
if opt.binary==16:
  mode='binary16'
elif opt.binary==8:
  mode='binary'
elif opt.dictionary:
  mode='dictionary'
else:
  mode='random'

i=0
while i<N:
  s=randstr(mode)
  # The string in s must be valid to get to this point, so print it.
  if opt.base64:
    print base64.b64encode(s)
  else:
    print s
  i+=1
