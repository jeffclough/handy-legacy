#!/usr/bin/env python

import base64,optparse,random,re,string,sys

 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Set up and handle the command line.
op=optparse.OptionParser(usage='''\
  %prog [options] [N]

Description:
  This command produces a single string of random characters according
  to the options given and writes it to standard output. Such strings
  are useful as passwords. If the N argument is given, that number of
  random strings will be output, one per line.''')

op.add_option('--classes',dest='classes',action='store',default='Aa2',help="The CLASSES value, which defaults to \"Aa1\", should contain one character from each character class (lower case, upper case, numerals, and punctuation) that must appear in the generated string.")
op.add_option('--bin',dest='binary',action='store_const',const=8,default=None,help='Generate a binary password of 8-bit characters.')
op.add_option('--bin16',dest='binary',action='store_const',const=16,default=None,help='Generate a binary password of 16-bit characters.')
op.add_option('-d','--dictionary',dest='dictionary',action='store_true',default=False,help="Use the system dictionary to compose the random password.")
op.add_option('-m','--min',dest='min_length',type='int',action='store',default=11,help="Minimum length of the generated random string. (default: %default)")
op.add_option('-M','--max',dest='max_length',type='int',action='store',default=15,help="Maximum length of the generated random string. (default: %default)")
op.add_option('--base64',dest='base64',action='store_true',default=False,help='Encode the password as base64 and output it after the plaintext password.')
opt,args=op.parse_args()
if opt.min_length>opt.max_length:
  opt.max_length=opt.min_length
  #print >>sys.stderr,"min (%d) must be less than max (%d)."%(opt.min_length,opt.max_length)
  #sys.exit(1)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

if opt.dictionary:
  lc=re.compile(r'^[a-z]{3,8}$')
  # Generate a random password composed from dictionary words.
  words=[ # Get list of all words from 3 to 8 lower-case charaters in length.
    w.strip().lower() for w in open('/usr/share/dict/words') if lc.match(w)
  ]

# Cook up some character class data based on the user's options.
class_n='0123456789'
class_l='abcdefghijklmnopqrstuvwxyz'
class_u='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
class_p='!@#$%^&*()-=_+~[]{}|;:,./<>?' # I've left out backslash and all quotes.
class_s=' '
classes=[class_n,class_l,class_u,class_p,class_s]
for i in range(len(classes)-1,-1,-1):
  if not any([ch in classes[i] for ch in opt.classes]):
    del classes[i]
if opt.max_length<len(classes):
  print >>sys.stderr,'For %d character classes, a maximum length of %d is too short!'%(len(classes),opt.max_length)
  sys.exit(1)
chars=''.join(classes)
non_alpha_classes=[
  s for s in (class_n,class_p,class_s)
    if any([ch in s for ch in opt.classes])
]

def generate_random_string():
  if opt.binary==8:
    # Generate an 8-bit binary password.
    print repr(''.join([chr(random.randint(0,255)) for x in range(random.randint(opt.min_length,opt.max_length))]))
  elif opt.binary==16:
    # Generate a 16-bit binary password.
    print repr(''.join([unichr(random.randint(0,65535)) for x in range(random.randint(opt.min_length,opt.max_length))]))
  elif opt.dictionary:
    #print >>sys.stderr,'--dictionary (-d) has not yet been implemented. Sorry.'
    #sys.exit(1)
    pw=''
    i=0
    while True:
      # Choose a random word from the dictionary.
      w=random.choice(words)
      # If we're using capital letters, capitalize each word.
      if 'A' in chars:
        w=w.capitalize()
      # If we're going to need another word, and if we're using non-
      # alpha character classes, use characters from those classes
      # to separate words.
      pw+=w
      l=len(pw)
      if l<opt.min_length:
        if len(non_alpha_classes):
          pw+=random.choice(non_alpha_classes[i])
          i=(i+1)%len(non_alpha_classes)
      else:
        # Validate length and character classe compliance.
        if l<=opt.max_length or all([any([ch in pw for ch in cl]) for cl in classes]):
          break # pw holds a valid password.
        # Otherwise, start over.
        pw=''
        i=0
      #print 'w=%r pw=%r'%(w,pw)
    print pw
  else:
    # Generate a printable password using the characters in the classes[] strings.
    length=random.randint(opt.min_length,opt.max_length)
    valid=False
    while not valid:
      # Start with a string of random characters from our various character classes.
      s=''.join([random.choice(random.choice(classes)) for x in range(random.randint(opt.min_length,opt.max_length))])
      # Ensure that all character classes are represented in our random string.
      cs=set([]) # Set of first character of each class found in the string.
      for ch in s:
        for c in classes:
          if ch in c:
            cs.add(c[0])
            break
        if len(cs)==len(classes):
          valid=True
          break
    # The string in s must be valid to get to this point, so print it.
    if opt.base64:
      print s+' '+base64.b64encode(s)
    else:
      print s


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

if len(args)>0:
  try:
    N=int(args[0])
  except:
    print >>sys.stderr,"The N argument must be an integer value."
    sys.exit(1)
else:
  N=1

i=0
while i<N:
  generate_random_string()
  i+=1
